Near Field Communication for User Centric IoT
Device Pairing and Authentication

Rasmus Karlsson, 41001
Master’s thesis in computer science
Supervisor: Jerker Björkqvist
Faculty of Science and Engineering
Åbo Akademi University, 2021

Abstract
Many IoT pairing methods that are currently in use suffer from poor security
due to, for example, choices made in order to make them more user-friendly.
Factors that contribute to the lack of security include too high levels of
automation and long-range wireless pairing without any authentication. The
aim of the present thesis was to investigate whether or not Near Field
Communication, or NFC, could be used to pair IoT devices and set up secure
network communication with improved security and ease of use compared to
other commonly used technologies. The main design goals of the NFC-based
pairing solution were to provide a system that is easy to use regardless of the
technological skills of the user, while providing decent security without
requiring any configuration by the user. Some important threats to IoT
security were explored, and alternative methods of pairing IoT devices were
presented and compared on a theoretical level to the NFC-based proposal. In
order to test the technical viability of the NFC-based pairing and
authentication solution, a prototype software was programmed and tested on
a suitable hardware platform. The results of the testing of the prototype were
then evaluated to see whether or not the prototype fulfilled the set design
goals. The testing showed that the proposed technology worked as expected
and fulfilled the set design goals with no major issues being encountered. In
conclusion, the NFC-based pairing method seems to be a technologically
viable option. With some further development, it could easily be adapted for
use in production systems.

Index
1. Introduction...................................................................................................1
2. NFC-based Solution Overview and Comparison with Alternatives..............5
2.1. General Overview of Factors in IoT Security........................................5
2.2. Analysis of Alternative Solutions...........................................................9
2.3. Advantages of NFC-based Solution....................................................13
2.4. Use Cases for NFC-based Solution....................................................15
2.5. Key Technologies Used......................................................................17
2.5.1. Public Key Encryption............................................................................17
2.5.2. Digital Signatures....................................................................................20
2.5.3. Near Field Communication.....................................................................22
2.5.4. Network Discovery Protocol...................................................................25
3. Implementation and Testing.......................................................................27
3.1. Overview of Practical Testing and Implementation.............................27
3.2. Hardware components........................................................................28
3.3. Software Components.........................................................................30
3.3.1. UDP Discovery Protocol.........................................................................31
3.3.2. Encryption Key Generation.....................................................................32
3.3.3. Near Field Communication.....................................................................33
3.3.4. Database of Received Encryption Keys..................................................36
3.3.5. Optional Peer-to-Peer Encryption Key Sharing......................................37
4. Results of Testing.......................................................................................40
4.1. Observations on Random Number Generation..................................42
4.2. Potential for Increased NFC Utilization...............................................43
4.3. NFC Mode for Initial Pairing................................................................44
4.4. NFC Eavesdropping and Physical Access..........................................46
4.5. Issues and Future Development.........................................................46
5. Conclusions................................................................................................49
6. Summary in Swedish – Svensk sammanfattning.......................................51

1. Introduction
While the internet used to be a tool that computers could use to communicate
over long distances, technology has evolved to a point where the ability to
connect to the internet can be included in many other types of devices.
These devices, which cannot be considered traditional computers, make up
what is known as the Internet of Things, or IoT. In many use cases, these IoT
devices need to be able to communicate with each other in a secure manner
over a network. With IoT devices rapidly increasing in popularity [1], the
growing number of IoT devices is also becoming a more attractive target for
cyber attacks [2]. Since IoT devices are designed and marketed towards
broad groups of consumers, choices are sometimes made that compromise
the security of these devices in order to make them more accessible to
people with varying backgrounds and degrees of knowledge of electronics
and computers. One such aspect, where security is often compromised in
order to make it easier to use devices, is how devices are paired or
connected to each other. In general, the issues with the methods used to
implement this pairing stem from automatic pairing via various wireless
technologies or via a network that is susceptible to eavesdropping or
malicious devices using said pairing method to pair themselves to the
system. Thus, the idea of using near field communication, or NFC, for pairing
was born. The idea was originally presented in my previous thesis [3], and
this thesis is based on the idea presented within it. The intention of this thesis
is to build upon the idea and test the viability of NFC as a method of pairing
IoT devices and setting up secure network communication between them.
The main goal of this project is to design a device pairing method that allows
any users, regardless of their level of knowledge of computers and
technology, to connect IoT devices to each other in such a way that they can
communicate securely with each other over a network after they have been
1

paired. In order to ensure privacy and information security, the information
that is sent needs to be encrypted to ensure that only the intended receiver
can access the information. Devices should also discard any messages sent
by devices that have not been paired to them, since recipient devices need to
ensure that the information has been sent to them by a device that has in fact
been paired to them. This can be accomplished by using digital signatures in
addition to encryption. Once these criteria have been fulfilled, it ensures that
only the intended recipient can receive the information that has been sent to
them, and the recipient can verify that the sender is one of the authorized,
paired devices. Of course, the devices implementing this NFC-based pairing
will sometimes need to communicate with remote servers for data
processing, storage or other purposes, but this data communication is not
covered by the NFC-based pairing and encryption method.
Ensuring that the proposed NFC-based pairing solution is easy to use for any
user, regardless of their background, is one of the primary goals of the
solution presented in this thesis. The intention is to create a system where
the users’ actions cannot compromise the security of the system through
uninformed actions, such as setting an insecure password or configuring the
system in such a way that it becomes susceptible to cyber attacks. Generally
speaking, ensuring adequate security in any given computer system requires
a level of knowledge that the average user cannot be expected to have.
Because of that, the proposed solution is designed so that it defaults to a
state that provides a decent level of security. The only action that the user
should need to perform to connect two devices is to bring the devices within
NFC range of each other, so that they can share their randomly generated
encryption keys to allow secure communication over the network from there
on out, as illustrated in figure 1.

2

People lacking the knowledge of or interest in technology and computers that
is needed to properly secure their networks and devices is a common issue
due to the fact that almost all people, regardless of their background, use
computers. Some people simply do not understand how to set up their
system correctly, or even realize that computer security is something that
they should be concerned with in the first place. Other users may avoid
changing anything about their own devices because they work just fine as
they are, despite all the security problems in their configuration. These and
other factors mean that people use network-connected devices that still have
their default passwords, outdated security protocols that are easily broken
today, or in the worst case, no security or encryption whatsoever, which is for
3

example commonly seen in WIFI access points. All these issues related to a
lack of knowledge or interest in the security of internet-connected devices
show that there is a clear need for more user-friendly encryption and
authentication methods, or better education, in these areas. One of the
biggest issues regarding computer security are the passwords that people
use [4], since it does not matter how good the encryption of a system is if the
user has chosen a password that an attacker can guess in just a few
seconds or minutes. It is common for people to use passwords that are easy
to guess or brute-force, and some even keep them written down, completely
bypassing the idea of passwords that are supposed to be kept secret.
Sometimes alternatives to passwords may be used, such as access cards,
badges or USB sticks containing encryption certificates, but they are also
subject to their own issues as they can be stolen, replicated or otherwise
compromised. Passwords, in an optimal situation, should only exist in the
mind of the user, but even then, practically any passwords are breakable
when enough resources are spent on breaking them.
The goal of this project is not to create a system that is capable of mitigating
every possible security factor or attack type. Rather, the focus is mainly on
reducing the negative impact on security that users with minimal knowledge
of how to configure IoT devices bring with them, as well as replacing less
secure wireless technologies with a technology that is inherently more
difficult to attack.

4

2. NFC-based Solution Overview and
Comparison with Alternatives

2.1. General Overview of Factors in IoT Security

There are many factors that affect how secure an IoT system, or indeed any
computer system, is. The focus in this thesis will mainly be on issues that are
relevant to IoT systems. It has become an accepted fact in the cyber security
industry that the users of any given computer system are one of the largest
security threats [5]. It is common for users to lack the knowledge to properly
identify and react to security threats, which means that phishing and other
social engineering attacks have become the go-to method for attackers to
gain access to computer systems [5]. Phishing attacks often take the form of
the by now commonly known emails that try to imitate a legitimate email in
order to spread malware or make users click a link that takes them to a signin page in order to steal their credentials for whatever service the attacker is
imitating. It is also not unheard of for phishing attacks to be done via phone
calls, where the attacker claims to be someone other than who he is. Often
this is done to make users share, for example, credentials or single-use
verification codes that are sent to the user when the attacker tries to log into
a system with the users’ credentials. While the less sophisticated of these
attacks are easy enough to mitigate with proper anti-phishing training,
especially in corporate settings, very well-researched, targeted attacks
sometimes take place. Such attacks would, to an untrained eye, seem to
have been sent from legitimate sources due to the knowledge of the target of
the attack that they contain [6].
Many users also do not understand the importance of proper passwords and

5

security. As a result, around 15 percent of all IoT devices are still accessible
by using their default username and password combinations which, in turn,
means that only five sets of credentials can give an attacker access to 10
percent of IoT devices [7]. This is a direct result of devices not requiring that
users set them up properly, with non-default credentials, before they can be
used. When users are forced to choose a password, it is extremely common
for them to choose a simple password, such as “1234” or “password”, or
other commonly used or otherwise simple passwords. A study at the Polish
Naval Academy concluded that 94.94 percent of tested student passwords
were easily cracked through various means, such as by using password
dictionaries, brute forcing and other methods [4]. Of course, companies and
programs often try to mitigate this issue by forcing users to choose a more
complicated password, and sometimes by forcing them to replace passwords
at set intervals. The drawback of these methods is that many users end up
writing down the password somewhere, or choosing more memorable
passwords, in order to reduce the impact that these password policies have
on them [8].
Social engineering attacks are also becoming extremely common, with 98
percent of cyber attacks relying on social engineering, according to a study
by

PurpleSec [5]. Additionally, a study by the security firm Positive

Technologies showed that 17 percent of malicious emails that they sent to
companies were successful at what, in a real attack, would have
compromised the system [9]. When combining these factors, it becomes
clear that social engineering attacks are a major issue in cyber security. The
attackers who perform social engineering attacks use a multitude of clever
methods in order to learn everything they can about the person they have
chosen to attack. Once they have all this information, they can sometimes
guess passwords based on the information, since many people use names,
important dates such as birthdays and other similar information that can
somewhat easily be found. If the password is not easy to guess, the next
step for the attacker is to make the user willingly hand over their password in
6

some way. This could, for example, be done by impersonating a person in
charge, a relative or someone from IT support, eventually convincing them to
give their password to the attacker for whatever made-up reason they may
give. The most complex social engineering attacks even work by having a
future attacker befriend the target of the social engineering attack, sometimes
making their acquaintance for months or even years. After all that time and
effort, they can then try to exploit the trust that many people have in their
friends in order to achieve whatever they are after.
There are also many other ways of stealing passwords from people, ranging
from key-loggers and well-placed hidden cameras to email phishing attacks.
Since the attacks can be extremely advanced, even well-educated users can
often be tricked by attackers. The conclusion that can thus be drawn is that a
more secure way of handling access control should be used where possible.
While passwords or physical alternatives can be difficult to avoid in userfacing applications, it is certainly possible in inter-device communication.
Another issue that is common among IoT devices is that they lose support
from the manufacturer, and thus security updates, while they are still well
within their expected lifetime. In some cases they may not even have
received any updates in the first place, especially if the devices have been
produced by less reputable manufacturers. This issue is not unique to IoT
devices either. A common problem with smartphones and other devices
running the Android operating system has been the lack of updates from
manufacturers [10]. Until Android 10 was released which began providing
security updates straight from Google [11], the creator of the Android
operating system, all updates had to come from the manufacturer. Since
manufacturers rarely support their devices with updates for more than two
years, and often less than that, it meant that devices that were still in use
would receive no updates to mitigate known vulnerabilities. The lack of
updates from IoT device manufacturers, coupled with rapid development
schedules for devices and companies lacking the security awareness to

7

properly develop secure devices, leads to devices that can have serious
security issues. This can make IoT devices a great attack vector for attackers
looking for ways to steal information, cause damage or gain access to a
network and any other devices connected to it [12].
Since many IoT devices are designed to be used by the general population,
who may possess varying levels of computer knowledge, they often
compromise security in order to make them easier for users to set up and
use. This includes using various insecure, often fully automated wireless
pairing and discovery methods that can not only be used by the intended
user, but also by an attacker who wants to gain access to or otherwise
manipulate the system [13].
As was explained in my bachelor’s thesis [3], most attacks against computer
systems can be grouped by the goal behind the attacks. In Threat
Implications of the Internet of Things [14], potential attacks against IoT
systems are split into three different categories depending on their goals. The
first type of attacks that the author describes are capture attacks, where the
goal is to get access to a system or the information it handles. These attacks
can, for example, give the attacker access to a particular device, or even a
larger network, via an insufficiently protected IoT device in the network. They
can also be done through physical attacks, for instance by connecting rogue
devices to the network, through social engineering attacks or by using a
number of other methods. These attacks can have serious consequences,
especially in systems that handle information that should remain confidential.
Having gained access to the system, the attacker could also continue
collecting data over a longer time if the attack is not discovered immediately.
The next type of attacks discussed by the authors are attacks where the goal
is to cause disruptions and other problems for the target of the attack. These
attacks can, for instance, consist of so called Distributed Denial of Service
attacks, or DDoS attacks for short. The goal behind DDoS attacks is to
overload the device or the network connection of the device that is being
8

targeted by the attack. Generally, these attacks work by sending a large
number of network requests to the target, in order to consume enough
network or processing resources that the target is rendered unable to handle
legitimate requests [15]. While these attacks do not normally lead to any
data leaks, they can still cause economic damage and other issues that stem
from the attacked system being unable to perform its normal tasks. There
have also been cases where this type of attack has been used as a mere
distraction from another attack [16].
The third and last type of attack that the authors discuss is what they call
manipulation attacks. In these attacks, the goal is to gain the ability to
manipulate the functionality of the IoT system in some way. This can be done
by, at some point in the information flow, modifying the information that the
IoT devices are trying to send to each other or to and from external servers.
One form of manipulation attacks is the so called man-in-the-middle attack,
where the attacker eavesdrops on the network communication and is able to
replace the information with its own information in order to affect the target
system in some way [17]. These attacks can have major consequences,
since they can lead to computer systems performing actions that are
completely different from what they are supposed to do. These attacks could
even be used to affect electronic voting systems, military computer systems
and other safety-critical systems. These attacks can also result in serious
data leaks.

2.2. Analysis of Alternative Solutions

There are many different ways in which IoT devices can currently be paired
to each other, with some methods being completely automatic and others
9

requiring varying levels of user input. These methods include devices
announcing themselves over Bluetooth or wireless access points created by
one of the devices, automatic pairing using various service discovery
protocols or even entirely manual configuration of the devices.
Automatic pairing using network discovery protocols has one major
advantage over most other pairing methods, the advantage being that it is
very easy to use. The only thing that the user needs to do is to plug in the
devices, assuming that they use a wired internet connection. For wireless
devices, an additional step is required in order to connect them to the
wireless network in some way. As soon as the devices are connected to the
same network, they are able to broadcast their presence on the network
using their service discovery protocol of choice, allowing other devices to
listen for their presence. As soon as a broadcast is received by a device, the
receiver becomes aware of the broadcaster and is able to begin
communicating with them. See chapter 2.5.4 for a more detailed description
of service discovery protocols. While the simplicity of using a discovery
protocol is a significant positive factor, one of the major drawbacks of using it
by itself is the inability for devices to configure themselves to use wireless
networks without user interaction. This effectively limits this option from being
used outside of wired networks unless another method of configuring the
wireless settings is implemented. From a security standpoint, relying on an
automated discovery method leaves the system vulnerable to rogue devices
joining the network. This can be partially mitigated by using MAC-address
whitelisting, where only devices with known, safe mac addresses are able to
use the network, virtual local area networks (VLAN) that isolate the IoT
devices from the rest of the network, and other types of advanced network
access control. However, such advanced network configuration is rarely an
option outside of networks used by enterprises or technology enthusiasts.
Such measures do not necessarily provide that much security either, since
for instance, MAC filtering is easy to bypass by spoofing the MAC address on
a rogue device [18]. In domestic use cases, a pairing method that works and
10

remains secure even on very simple network setups would be advantageous.
Even in certain enterprise situations, such as in smaller businesses, a
solution that does not require such advanced configuration can still be
beneficial. One of the positive aspects of relying on network configuration to
decide what devices are allowed to connect to each other is that the
individual IoT devices need less configuration, allowing a more centralized
approach to configuring the IoT network.
Using Bluetooth, a wireless network hotspot or another equivalent wireless
beacon created by one of the IoT devices, effectively removes the need for
advanced network configuration in order to ensure secure communication.
These wireless pairing methods also make it possible to share additional
information such as wireless network configurations between devices at the
time of pairing, but they also introduce a few new potential issues [13].
Regardless of which of the aforementioned wireless technologies is used, the
basic principles and issues are generally the same. These pairing methods
all work by having a device announce its presence wirelessly, making it
possible for other devices to detect it and connect to it in order to exchange
information. These pairing methods can be configured so that the wireless
beacon is constantly on, allowing devices in their vicinity to detect and pair
with them at any time. This is simple from a users perspective, since it rarely
requires much more interaction than turning on the devices that need to be
paired, regardless of if the devices are separate IoT devices or something
like an IoT device and a smartphone. The main issue with a beacon that is
constantly turned on is the same as with automatic network discovery
protocols, since it allows any new, potentially rogue devices that are
introduced to the vicinity of a legitimate device to pair themselves to it.
Additionally, these wireless pairing technologies do not even necessarily
require that the devices are connected to the same network, enabling attacks
without physical access to the network. These wireless communication
technologies also have very long ranges compared to NFC, which is usually
considered a good thing. The drawback is that anyone with a good enough
11

antenna can communicate with these wireless devices over very long
distances, if close physical access is not an option for an attacker. These
wireless pairing technologies can also be configured to require some action
in order to enable the wireless pairing, such as pressing a physical button on
the device itself. This reduces the odds of attacks significantly, thanks to the
small time window in which a rogue device could pair itself to the legitimate
device. However, a well planned attack could be set up in advance, waiting
for months or even years for an opportunity to attack. In systems that are set
up in public spaces, allowing pairing to be enabled via a physical method
such as a button can also be an issue.
Another system that is less common, but not unheard of, in IoT systems, is
one where a device provides a graphical user interface through which IoT
devices can be paired and configured. This user interface can either be
provided on a display on the device itself if it has one, through a mobile
application or through a web browser. This is best suited for IoT systems that
have a central hub, which connects to and controls all the other devices,
since systems with multiple separate user interfaces for separate devices can
be difficult and confusing to use. Within this user interface, any devices
discovered via a service discovery protocol can then be listed, allowing users
to pick which devices are to be paired with the hub that is being configured.
This system can, if correctly set up, be very secure. It does however suffer
from all the potential security issues associated with traditional passwordbased logins, unless the interface is advanced enough to use more secure
forms of authentication. Depending on how well the user interface is
designed, there is also a risk that any detected rogue devices could blend in
with the other devices, leading to the user accidentally pairing them with the
hub as well. This can be hard to mitigate, but some strategies, such as
prominently showing a short but unique code both on the device and in the
interface, or requiring such a code to be manually input, can go a long way
towards mitigating this issue. From a user-friendliness perspective, this
solution can also be very complicated, especially for people with little
12

knowledge about systems of this type. That effectively limits this type of
pairing and configuration to IoT systems that are intended for enterprise or
technology enthusiast use.

2.3. Advantages of NFC-based Solution

The NFC-based pairing and authentication method provides certain
advantages over many of the commonly used alternative solutions. The NFCbased method achieves the same end result as far as pairing devices is
concerned, while being inherently more secure than many commonly used
alternatives. Despite this, it still manages to achieve a high level of userfriendliness.
The first of the alternative pairing methods mentioned in the previous
chapter, naively uses a service discovery protocol to find any available
devices to communicate with. While the ease of use achieved by a
completely automated solution is difficult to beat, the security of such a
solution is practically non-existent. Since any devices on the network are able
to communicate with each other, any security policies governing which
devices can communicate with each other must be implemented separately
from the pairing method itself. Any such implementation that an additional
configuration layer to the system, runs the risk of negatively impacting the
easy setup of the system. Compared to this option, the NFC-based solution
provides a much greater level of security, thanks to factors such as manually
having to choose which devices to pair, and sharing encryption keys in a
non-networked manner. Despite the improvements in security, the actions
required from a user to set up the system can still easily be printed on the
device itself, or on the packaging, in just a few words, keeping the system
13

fairly easy to use. The only actions that the NFC-based solution requires from
the user, are that they plug in and power on both devices, and put them next
to each other, until given either a visual or auditory confirmation to signal that
the pairing was successful. After that point, the devices can be plugged in at
their permanent locations where they will be able to communicate with each
other as long as they have access to the same network.
The next alternative pairing method mentioned in the previous chapter is one
where a device uses a wireless access point, Bluetooth or another equivalent
long-range wireless technology to announce their presence, allowing other
devices to pair with them. This pairing method actually has a lot in common
with the NFC-based solution, with the main difference being the
communication technology used. Both solutions are closely matched with
regards to their ease of use, depending slightly on how the Bluetooth or WiFi
based alternative is implemented. If it is completely automated, having to
bring the NFC-based devices next to each other may be slightly more
complicated than the alternative. If the alternative requires more interaction
by the user, on the other hand, the NFC-based solution may end up being
very slightly easier to use. Where the NFC-based solution wins in this case,
is in the physical security provided by the highly limited range of NFC when
compared to most other wireless communication technologies. Since NFC is
generally limited to a range of a few centimeters in normal use cases [19], it
effectively stops wireless attacks from happening at a longer distance. NFC
also forces the user to choose which devices to pair in a physical manner,
making accidental pairings to unintended and possibly harmful devices more
difficult.
The last solution mentioned in the previous chapter is one that is based on a
traditional user interface, either web-based or otherwise, where the user has
to log in in order to manage the IoT system and choose which devices to pair
together. While this system allows the highest level of configuration and
security, it also suffers from being by far the most complicated system. This

14

manifests itself not only as a system that can be harder to use, but also as
one that can more easily end up being poorly configured due to a lack of
knowledge of the system on the users part. This can, in turn, affect the
security of the system negatively in many ways, for example through poor
password choices or interfaces that are easy to access for potential
attackers. This alternative is also only really suitable for systems that can be
configured from one central device acting as a hub or server. This type of
interface is commonly used in internet modems that can be found in most
homes, and they often end up being deployed with their default login
credentials still in place [7]. Luckily, they also usually default to only allowing
access from the local network. Even so, an attacker that manages to access
the network either via a poorly secured wireless network or by gaining access
to a physical Ethernet port, will also easily be able to access the modem, or
in this case the IoT system, unless a knowledgeable user has configured it
well.

2.4. Use Cases for NFC-based Solution

The NFC-based pairing and authentication solution is mainly intended for IoT
systems designed for use in homes and in certain smaller businesses that do
not require enterprise level security and control, and which may lack
knowledgeable IT personnel on staff. The reasoning behind designing the
system for these use cases is that the NFC-based pairing and authentication
solution allows for a decent level of security in situations where devices
implementing it are unlikely to be attacked by anything more than
opportunistic hackers. Some companies and high-profile individuals can
become the target of much more sophisticated attacks that are tailor-made
for the situation at hand. In companies where that may be the case, due to
15

factors such as valuable data being handled in the company, or simply
because of the size of the company, any network-connected devices need to
be configured, secured and kept up-to-date in a much more advanced
manner than what most off-the-shelf solutions allow. User-friendliness is not
the main concern in such environments either, since they usually have
access to highly trained IT professionals that can configure any devices in
the manner that is required for their unique situation.
In normal domestic and small business use cases, attacks against IT
systems are on the whole very rare occurrences, and a majority of all attacks,
at 88 percent, are so called opportunistic attacks that attempt to take
advantage of poorly secured systems without targeting any particular victim
[20]. One example of where this can easily be seen, is in the constant flow of
login attempts on any SSH server that is accessible from the internet. It is
also easy for an attacker to plant a device or walk around in public with a
computer that is trying to access unsecured networks, Bluetooth devices and
other insufficiently protected devices. These are the main types of attacks
that this system aims to prevent, in order to provide a decent level of security
to people that would not otherwise know how to set up a secure IoT system.
The encrypted and signed network communication effectively prevents many
types of attacks which rely on an insecure or otherwise poorly configured
network that is accessible to the would-be attackers. Using NFC as the
communication technology for the pairing stage effectively stops people on
the street from getting access to the system, due to the very short range of
NFC, unlike more common Bluetooth and WiFi based solutions. To get an
idea of how accessible these types of networks can be, one only needs to
take a walk in a densely populated area while scanning for wireless networks
and Bluetooth devices with a smartphone or computer. The amount of these
networks, often still configured on their default, out-of-the-box state, is
surprisingly high [21].
On the hardware side

of things, the NFC-based encryption and

16

authentication solution can be adapted to most IoT systems that consist of
more than one device, although it is worth pointing out that devices that only
communicate with the cloud, as opposed to direct communication between
devices, will not benefit from this technology. There are many different types
of IoT systems that are suitable for this encryption and authentication
method, but some good examples include CCTV systems that store data on
a local storage device, sensor networks and various smart home devices.
The proposed solution can be used in IoT systems where several devices are
managed by a central hub or server, but it can also be used in systems
lacking such a central device, where the devices instead communicate
directly with each other. If devices should be able to communicate with more
devices than just a single central hub, implementing the proposed peer-topeer encryption key sharing can be advantageous. This makes pairing new
devices only once to any device in the IoT network sufficient, rather than
having to pair it to every single device with which the new device is supposed
to be able to communicate.

2.5. Key Technologies Used

2.5.1. Public Key Encryption

Any devices that want to send messages between each other in a secure
manner, where only the intended receiver can read the message, need to
implement some form of encryption. The purpose behind encryption is to
avoid sending a message in a format that anyone can read, if they were to
get their hands on it. Encryption turns such plaintext messages into

17

unrecognizable ciphertext, by using a reversible cryptographic algorithm. This
ciphertext is then practically useless for anyone who does not possess the
algorithm used to turn it back into a readable format. The cryptographic
algorithms work by having set mathematical formulas which are used to
encrypt and decrypt information. These algorithms take the text that is to be
encrypted or decrypted, along with what is knows as an encryption key, and
modify the original information, represented as numbers, into a different,
unrecognizable number. Once the decryption algorithm is applied on the
ciphertext by using the correct encryption key, the information is returned to
how it was before the encryption. If the algorithm is applied with the incorrect
encryption key, the result is another practically useless string of numbers
[22]. By making the encryption keys long enough, typically 2048 or 4096 bits
for modern RSA keys [23], the key becomes extremely time-consuming to try
to brute force by iterating through every possible key, providing an adequate
level of security for most common network communication.
Encryption algorithms can be split into two main categories, namely
symmetric and asymmetric encryption algorithms [24], the differences of
which are illustrated in figure 2. Symmetric encryption algorithms use the
same encryption key to both encrypt and decrypt information. This means
that anyone that gets access to the key will be able to not only receive and
decrypt any messages encrypted with that key, but also send out correctly
encrypted messages. Thus, keeping the encryption key secret is extremely
important when using symmetric encryption. This makes symmetric
encryption a poor choice in most networking use cases. Symmetric
encryption is still useful though, for example in use cases where one needs
to encrypt data at rest [25], where the data is both encrypted and decrypted
in the same location. This can include applications such as hard drive, device
or file encryption.

18

Asymmetric encryption algorithms, also known as public key encryption
algorithms, use separate encryption keys for encrypting and decrypting
information. These keys are called public and private keys, and as the names
suggest, one of these keys is intended to be shared with others, while the
other is meant to be kept private and secret. Asymmetric encryption
algorithms work by encrypting data with one of the keys, which makes it
decryptable only by using the other key from the so called key pair. This
means that one can publicly distribute the public key, since any information
encrypted with it will only be decryptable by the intended recipient who
possesses the corresponding private key. The keys can also be used the
other way around, by encrypting with the private key and decrypting with the
public key, but that is generally less useful since it allows anyone with the
potentially publicly available key to decrypt the information [24].

One of the most popular encryption algorithms in networking applications is
called the RSA algorithm, short for Rivest-Shamir-Adleman [26]. The
algorithm was first published in 1977, and has since become one of the most
popular encryption algorithms in computer networking, used by software
libraries such as openSSL, which is used by the majority of HTTPS servers
to provide encryption on the world wide web [27]. Since the RSA algorithm is
an asymmetric encryption algorithm, it uses a public and a private key. The
19

security of the RSA algorithm is based on the difficulty of factoring large
numbers that are the result of multiplying two large primes [28], while
calculating said numbers is relatively easy.
The RSA encryption key generation process is as follows [26]:
1. First, one has to select two random prime numbers, P and Q.
2. Then one calculates N = PQ
3. Then, one calculates the totient Φ(N) = (P-1)(Q-1)
4. Then, one selects E>1 which is a coprime to Φ(N). In practical
implementations, this is often selected in advance, and for every
calculated totient, a verification that E is in fact coprime to the totient is
performed. If this condition is not fulfilled, new primes are generated
and a new totient calculated.
5. D is calculated as the modular multiplicative inverse of E(mod Φ(N))
Once these calculations have been done, the public key consists of N and E,
and the private key consists of N and D. If the value of E is predetermined
and known by both parties to the encrypted communication, only the N from
the public key will have to be shared with the party that needs to know the
public key. In order to encrypt a message M using the public key, the formula
C(M) = M^E mod N is used. In order to decrypt an encrypted message C
using the private key, the formula M(C) = C^D mod N is used.

2.5.2. Digital Signatures

As explained in the previous chapter about encryption, any information that is
to be sent to a particular recipient, is encrypted using the public key
belonging to the intended recipient. This ensures that only the intended
20

recipient can decrypt and read the information by using their private key to
decrypt the message it received. This does however lead to a problem. Since
the public key is by definition public and theoretically available to anybody,
that means that anyone with access to the public key could also send an
encrypted message that the recipient will then successfully decrypt and act
upon. This is an issue, since it leaves devices open to manipulation by
anyone who has access to the public key, unless we somehow make sure
that the sender is also an authorized device that has already been paired to
the receiver of the encrypted message.
One of the easiest ways of verifying the identity of the sender is by using
digital signatures, which for all intents and purposes work exactly exactly like
normal RSA encryption, only applying the encryption keys in reverse. Instead
of encrypting information with the recipient’s public key and decrypting it with
the recipients private key, digital signatures work by encrypting the message
with the private key of the sender and decrypting it with the known public key
of the claimed sender. If this decryption is successful, it means that the
sender had access to the private key of the claimed sender of the
information, and assuming that the private key has not been leaked to or
cracked by malicious actors, this means that the sender is who it claims to
be. Since each device should already have the public keys of any other
devices that it has been paired to, this technology requires no additional
information to be known by the sender or the recipient of encrypted and
signed information. Digital signatures do not replace the normal RSA
encryption, however, since anyone with the senders public key can decrypt
the information. Instead, digital signatures should be used by first applying
the signing algorithm to the message that is to be sent, resulting in a
ciphertext version of the message. After the message has been encrypted
using the senders private key, meaning that it has been signed, it can then
be encrypted with the usual RSA algorithm using the recipient’s public key.
Once the recipient receives the message, it will then begin by decrypting the
message normally with its own private key. After the message has been
21

decrypted, the resulting signed message is then decrypted using the claimed
senders public key. This decryption results in a plaintext message if the
decryption is successful. If it is not successful, that would indicate that the
sender is not who it claims to be, and that the signature is not valid [29]. This
order in which encryption keys are used when signing, encrypting and
decrypting with RSA is also illustrated in figure 3.

22

2.5.3. Near Field Communication

Near Field Communication, more commonly known as NFC, is a wireless
communication protocol defined by the ISO/IEC 18092:2013 standard [30].
NFC is intended to be used at very short distances, ranging from millimeters
to a few centimeters [19]. When using NFC, there is always one device
known as the initiator, and another device known as the target. The
difference between the initiator and the target is that only the initiator is
allowed to power its antenna in order to generate the RF field used for
communication between the devices. The initiator is also, as the name
implies the device that has to initialize each NFC data exchange transaction,
making it act in a similar manner to the master device in many other
communication protocols which utilize a master and a slave device. When
the initiator is sending data to the target, it generates and modulates its own
RF field, allowing it to be detected and read by the target. When the target is
sending a response, the target then modulates the RF field generated by the
initiator, allowing the initiator to receive a response from the target. In
situations where both devices have their own sources of power, there is also
an option called active mode, where the device that is currently sending data,
whether that is the initiator or the target, powers the RF field, while the other
device passively reads the data [30]. One of the advantages of NFC in many
use cases is that the target does not need to supply its own power, making it
possible to build passive devices such as NFC tags and key cards.
NFC can operate in one of three operating modes, described in “A Review on
the Operating Modes of Near Field Communication” by Ekta Desai [30], and
illustrated in figure 4. The three operating modes include reader/writer mode,
peer to peer mode, and card emulation mode. Reader/writer mode is used by
the initiator device to either read data from or write data to, depending on in
which mode the connection is initialized, a passive NFC device. This is the
operating mode that is used to interface with NFC key cards, bus passes and
23

other passive NFC devices.

Peer to peer mode is in many ways the most flexible operating mode as far
as use cases go, since it is designed to allow two active NFC devices to send
bi-directional data of any kind between each other. This can be done either
by sticking to the principle of having the initiator power the RF field and
having the target modulate it when it wants to send data, or by using the
aforementioned active mode where either device can power the RF field
depending on which device is currently transmitting. The peer to peer mode
is what is the most relevant to the use case presented in this thesis, since it
is what is used to transfer data between the IoT devices that are being
paired. This communication mode is also suitable for sending information
between mobile phones, either to send data directly over NFC, or to transfer
the information needed to automatically set up an alternative wireless
transfer method.
The card emulation mode allows powered NFC devices to act as if they were
a passive NFC card or tag, which can then be read by an initiator as if it was
a normal, passive NFC device. This is mostly useful in mobile phones, where
it allows the phone to replace other things, such as transit and payment cards
that use NFC. This NFC mode is used in technologies such as Apple Pay
[32].
24

2.5.4. Network Discovery Protocol

In order to allow IoT devices to find each other on the local network, a
discovery protocol is often used. Discovery protocols work by having network
services, or in the case of this project, devices, announcing their presence on
the network. This is generally done by sending out UDP broadcasts, or more
commonly multicasts, to an agreed-upon address and port in the network.
This makes it possible for anyone who is listening to this multicast to know
that a particular service or device is currently running, as well as providing
the IP address where it can be reached [33].
There are many different types of discovery protocols available for different
uses. Two examples of such protocols are Simple Service Discovery
Protocol, abbreviated SSDP [34], and Universal Plug and Play, abbreviated
uPnP [34], which itself utilizes the former protocol.
If a discovery protocol would not be available, it would be much more difficult
for devices and services on a network to communicate with each other. In
most networks, IP addresses are dynamically assigned to devices, meaning
that they are subject to change over time. This dynamic assignment is done
using the Dynamic Host Configuration Protocol, more commonly known as
DHCP [35]. The consequence of using dynamic IP addresses is that the
current address of a given device or service is not known by default. A
discovery protocol can make the current dynamic IP address known, but
another alternative is to use static IP addresses, which are manually
configured and will never change. That way, the IP address will always
remain the same, and the need for a discovery protocol is eliminated. The
drawback of static addresses is of course the significant manual configuration

25

effort needed to initially set it up. For certain use cases, knowing the IP
address of the service or device one is trying to communicate with may also
not be necessary, if all communication can be done using UDP broadcasts or
multicasts.

26

3. Implementation and Testing

3.1. Overview of Practical Testing and
Implementation
In order to evaluate whether or not utilizing NFC to transmit RSA encryption
keys between IoT devices is a viable option to facilitate device pairing, a
simple proof-of-concept system was built and programmed. This proof-ofconcept was built with the necessary hardware and software components to
test the functionality to a level that would allow it to be evaluated against the
design goals of the NFC-based pairing solution. It does not, however, fulfill all
the criteria for a complete production system as outlined in this thesis, nor
does it fulfill criteria set by various industry standards and best practices from
programming and security perspectives. The intention is to test whether or
not the solution is technically feasible, and if it is, to compare it with the
design goals to evaluate if it meets, exceeds or falls short of the set goals.
Certain parameters, such as transfer speed over the NFC connection, will
also be tested in order to evaluate whether or not full-size encryption keys
and potential other data can be transferred in a reasonable time. Such
parameters will be tested in the code itself, by measuring the time it takes
between the start of the transmission and the end of it, including any
overhead caused by necessary data processing and other factors.

27

3.2. Hardware components

While this proposed NFC-based pairing solution is intended for embedded
devices with limited resources, the decision was made to run and test the
proof-of-concept solution on more powerful hardware that is easier to debug
and work with. Two Raspberry Pi [36] single-board computers running
Raspberry Pi OS, a Linux distribution based on Debian, were selected as the
experiment platforms. The Raspberry Pi is available globally, allowing for
easy testing and further development of the proof-of-concept code. In order
to facilitate testing of the network component of the software, they were
connected to the same local area network. These Raspberry Pis were then
paired with Grove NFC modules [37], which are based on the commonly
used and well-supported PN532 transceiver module [38]. They were then set
up to communicate with the Raspberry Pi using a universal asynchronous
receiver-transmitter, more commonly known as “UART” [39], which enables
serial communication between the PN532 and the Raspberry Pi. Even
though this hardware setup does not fully represent a realistic system where
this solution would be deployed, the code should be very easy to port to
many other hardware environments. The hardware used to test the proof-ofconcept implementation is shown in figure 5.

28

Figure 5: Hardware used to test the proof-of-concept implementation. The two large circuit boards
are Raspberry Pi single board computers, the two smaller blue circuit boards are Grove NFC
modules and the two small black circuit boards are NFC antennas.

Most real-world implementations of NFC-based IoT pairing will not use an offthe-shelf solution with a fully featured processor capable of running a normal
PC operating system, as the Raspberry Pi does. Rather, they will generally
be based on a custom circuit board with a microcontroller that features builtin Ethernet support or wireless networking support. The PN532 or a similar
NFC transceiver will most likely still be used even in real-world
implementations. This type of hardware enables low-cost hardware capable
of interfacing with numerous sensors and other hardware needed to enable
whatever functionality the IoT device needs to support.

29

3.3. Software Components

Most commonly used programming languages and compilers limit the length
of integers to values such as 32, 64 or 128 bits, depending on the capabilities
of the hardware that the program will be run on. There are some exceptions,
such as the Python programming language, which natively support arbitrary
length integers that are only limited by available memory, but C and C++
which are the most common languages used in embedded programming [40]
do not support arbitrary length integers natively [41]. Since the proof-ofconcept is written in C++, and numbers such as prime numbers and
encryption keys used by the RSA algorithm are too long to fit even in 64-bit
integers, a solution is needed to store and perform mathematical operations
on numbers larger than what is natively supported. There are software
libraries available for many languages that are designed to store arbitrary
length integers in arrays and perform mathematical operations directly on
these arrays. Such libraries are commonly referred to as big integer libraries,
or “bigint” libraries. The library that was selected for this project is “The GNU
Multiple Precision Arithmetic Library”, or GMP for short [42]. The reason
behind the choice of this library is that it includes support for many useful
arithmetic functions for generating and using encryption keys, making it
optimal for this use case.
The PN532 NFC transceiver module is the next component that warranted
the use of a software library to easily interface with it without having to write a
custom solution. Since the PN532 is such a common component, most NFC
libraries include support for it out of the box. For this particular hardware and
software environment, a library called “libnfc” [43] was chosen, since it
supports

the

PN532

transceiver

module

as

well

as

peer-to-peer

communication between NFC devices. Libnfc is also directly compatible with
30

the Raspberry Pi, which gave it an advantage over many other libraries for
the proof-of-concept implementation.
In order to simplify the networking aspect of the code, the network
communication is based on a somewhat modified combination of two code
examples from GitHub [44], [45], since they provided an easy way to
implement both the listener and sender for the UDP multicasts that devices
use to announce themselves on the network.

3.3.1. UDP Discovery Protocol

While there are many readily available network discovery protocols available
to choose from, the decision was made not to use any particular standard
discovery protocol for the proof-of-concept implementation. Due to the
minimal requirements on the discovery protocol in the proof-of-concept
implementation, a simple UDP multicast is used instead, which only
announces what uniquely identifiable device is currently connected at a given
IP address. The reason for this minimal discovery protocol is that these
devices only need to be discoverable by other devices belonging to the same
IoT system. This means that hat they can all be configured to listen to the
same multicast address, rather than making their announcements and
listening to a standard address and port used by many other types of devices
on the network. This choice of a simpler discovery protocol is also beneficial
on highly resource-limited IoT devices that may not be able to implement one
of the commonly used discovery protocols due to resource constraints. If the
resources are available for it, however, there is no other noteworthy reason
to avoid using a preexisting discovery protocol in production implementations
of this system. In any IoT systems where unrelated devices, such as ones

31

from different systems or manufacturers are expected to be able to
communicate with each other, it would be beneficial to use a more
standardized discovery protocol.

3.3.2. Encryption Key Generation

Since one of the goals of this thesis is to propose a method of pairing which
does not use potentially insecure passwords, they need to be replaced with
something else. Since encryption is already essential for secure internet
communication, it makes sense to utilize certain inherent properties of
encryption algorithms as a form of authentication as well. This can be done
using public-key, or asymmetric cryptography, where the encryption keys
consist of paired public and private keys. The idea behind public-key
cryptography is that the public key can be distributed openly, while the
private key is only known to the owner of the key in question [24]. In the case
of the proof-of-concept implementation, the goal is for two devices to
exchange public keys via NFC, enabling them to encrypt messages in such a
manner that only the intended receiver will be able to decode a message with
their private key.
While there are many popular public-key algorithms and software libraries,
the decision was made to create a custom, lightweight implementation of the
RSA

algorithm

[26].

The

decision

to

use

a

custom

encryption

implementation, rather than one of the numerous available software libraries,
is mainly motivated by the limited system resources available on many
embedded devices. Implementing the RSA algorithm from scratch makes it
possible to only include the features that are absolutely necessary in this
particular use case, rather than including all of the usually extensive

32

functionality of encryption libraries. It also allows for easier memory
optimization when writing code for platforms with limited hardware resources.
For production software implementations, a library that is considered secure
by cybersecurity professionals, or a custom implementation written by
cybersecurity and cryptography experts, is a more secure option than this
implementation which only focuses on minimalism and working as part of a
proof-of-concept.

3.3.3. Near Field Communication

In the NFC-based IoT device pairing method, NFC is used to transfer
encryption keys and device information between IoT devices, in order to
enable secure communication over a network connection after pairing. Many
other wireless communication technologies could be used to accomplish the
same tasks that NFC is capable of, but NFC has certain advantages over
many alternative wireless technologies that are beneficial in this use case.
One of these advantages is that it has a highly limited range of just a few
centimeters [19] in normal use cases, which makes remote wireless attacks
much more difficult than they would be against wireless technologies that
allow communication over longer distances. Even with high-powered
commercial RF equipment, studies have shown that the theoretical
eavesdropping range of NFC is still very limited, and such equipment is
difficult to use in a stealthy manner to perform attacks [46]. Table 1 shows
the maximum eavesdropping range found in one study using a fairly
rudimentary hardware setup.

33

Table 1: Maximum eavesdropping range test results [46].

This means that an attacker would have to have close physical access to one
of the IoT devices in order to pair a rogue device to it. Some buildings and
locations already provide an adequate distance between areas accessible to
the public and the locations where IoT devices would be installed. In cases
where devices will be installed close to exterior walls, outdoors or in other
public places, this type of physical security cannot be relied on. In such
implementations of the NFC-based pairing and authentication system, it
would thus be beneficial to disable the NFC on each IoT device when it is not
actively being used to pair devices. This can be done in several ways,
depending on which circumstances the device will be deployed in. In some
scenarios, where potential attackers are unable to access the physical
devices themselves despite being able to get close to them, a simple pairing
button can be used on the device to turn on the NFC only when it will be
used for pairing. In situations where the devices may be completely
accessible to the public or where they need an even higher level of security
for other reasons, one solution could be to permanently disable the NFC
transceiver once a device has been paired to another device. This could, for
instance, be accomplished by having a hub device that is placed in a secure
location, which has either always-on or toggle-able NFC. Any new devices
can then be paired to this secure hub device. After pairing, the NFC
transceiver on the new device is permanently disabled until the device is
factory reset. Once a device has been reset, it can no longer be used to gain
access to the rest of the IoT network, making it safe to enable pairing again.
Another significant advantage that NFC has over many other communication
34

technologies is the low power draw [38] and minimal electronic circuitry
required in order to implement it in a device. The only major components
needed are an NFC transceiver, such as the NXP PN532 [38], and an RF
antenna, which can even consist of traces on a printed circuit board, as is the
case with the Grove NFC module [37]. The hardware required to implement
NFC is also inexpensive, and unlike some other technologies such as
Bluetooth [47], there are no licensing costs involved with implementing NFC
in a product that one is developing. These factors make NFC a suitable
technology even for low-powered devices, such as ones running on battery
power, and devices that are heavily constrained by either price or size
limitations.
Another advantage of NFC over longer-range wireless communication
technologies is that it makes it difficult for users to accidentally pair the wrong
devices, or pair a device to a rogue device that has been placed nearby.
Since NFC requires that users physically pick up and move the devices that
are being paired very close to each other, it forces the user to physically
select the devices that the user wants to pair.
At a minimum, in any real-world implementation of this system, the
information that is shared over NFC should include the information shown in
table 2. All the data should be shared bi-directionally between the two
devices that are being paired. In more advanced systems, it may also be
advantageous to share other information about each device, such as what
type of device it is and what capabilities it has. For the sake of simplicity, the
proof-of-concept does not share anything other than the public key, since
there were only two predetermined devices available which were used to test
the prototype.

35

Table 2: An example of the minimum information required for an entry in a database of paired
devices.

Name

Description

Public key

Public RSA encryption key of the remote
device

Unique device identifier

A unique code identifying a device so
that the correct encryption key can be
used when attempting to decrypt data
from another device

3.3.4. Database of Received Encryption Keys

Each device needs to store all the information it has received via NFC pairing
from other devices. The easiest way to handle this is by storing it in a
structured manner, either in a database, as an array or in an easily parseable text file. Two good options for such a file would be to store the data
using JSON, short for JavaScript Object Notation [48], or CSV formatting,
short for Comma-Separated Values [49], but the format is completely up to
the developer and the requirements of the system that is being developed.
The information that needs to be stored includes, at the very least, all the
information from table 2, but it may also be advantageous to store other
information about the device. Such information can either be transferred via
NFC at the pairing stage, or later on over the local network that the devices
are connected to. It is also necessary to store information about what devices
36

are announcing themselves using the UDP discovery protocol. This can be
done by storing an up-to-date list of IP and unique identifier pairs, but since
this information changes over time and can be rebuilt after a reboot, there is
no need to store it to persistent memory. Utilizing persistent memory to
reduce the random access memory consumption may still be advantageous
on highly memory constrained devices where conserving memory is
important. When memory conservation is not that important, the data can be
stored in random access memory, for example in a two-dimensional array or
other data structure that makes it easy to access the information as needed.

3.3.5. Optional Peer-to-Peer Encryption Key Sharing

There are two commonly used network architectures in IoT systems, as
described by [50], which will be familiar to anyone who is used to traditional
computer networks. One is in many ways similar to the traditional clientserver architecture, where one central device acts as a server in the IoT
network, referred to as the hub in this thesis and by some manufacturers.
This hub then communicates with a number of client devices that are
connected to it via an internet connection, or via some other method of
communication. The alternative is a peer-to-peer architecture, where a
number of IoT devices are connected to the same network, but with no
central hub. Instead, the devices communicate directly with each other and
with any devices controlling them, such as smartphones, within the network,
as is illustrated in figure 6. Either of these architectures can also utilize
remote servers, and in some systems the remote server may take on the role
of the hub in the first architecture. In that case, all communication goes
through and is handled by a server in the cloud, rather than being processed
locally.
37

In systems where all the IoT devices belonging to the system need to
communicate securely with each other, without allowing unauthorized
devices to send or receive messages, individually pairing each device with
every other device quickly becomes impractical as the number of devices
grows. Instead, it would be easier if each device were to share its database
of known, paired devices, and their public keys, with all the other devices that
the device is paired with via a peer-to-peer system. If every received
database is then parsed, and new information inserted into the recipients
database, this should eventually lead to all the information about paired
devices that any given device has received being propagated to all other
devices. This should eventually allow any device that has been paired to a
device in this group to begin to communicate with all the other devices. To
avoid sending these databases to other devices constantly, a timestamp can
38

be added to each database that records at what time the latest addition was
added to this database. If this timestamp is then sent to other devices, and
the receiving device has an older timestamp in its own database, it can then
request the full database to be sent. Then, once the new information has
been added to the receiver’s database, it can adopt the newer timestamp
from the received database, making both timestamps match. By adopting the
new timestamp rather than generating a new timestamp at the time the
receiver’s database receives the new information, a situation where
information goes back and forth forever due to the other device always
having a newer timestamp is avoided.

39

4. Results of Testing
The proof-of-concept implementation of NFC-based IoT device pairing
successfully proves that NFC is a viable option to pair devices and transfer
information, such as encryption keys, between them, which can later be used
to enable encrypted communication between the devices. While this proves
that the technical implementation is possible, the question of whether or not it
fulfills the other design goals remains to be answered. To summarize the
design goals, the intention was to create a method for pairing IoT devices,
which requires minimal technical knowledge from the user, is easy to use and
achieves a decent level of security in its default state.
The design goal of providing a decent level of security was achieved thanks
to a combination of factors. These factors include certain inherent properties
of NFC, which provides some security thanks to its short range [19], and also
allows for further security by encrypting the NFC traffic, if that is deemed
necessary. On the network side, RSA encryption [26] and digital signatures
[29] ensure that messages are only readable to the intended receiver, and
only if sent by a known safe sender. There is also, by default, very little that
the user can do to accidentally make the system more vulnerable to attacks,
thanks to the lack of configuration options or potentially insecure methods of
authentication.
One of the major design goals was to create a system that would require
minimal technical knowledge or user interaction, while keeping any
necessary interaction as simple and minimal as possible. This design goal
was achieved, save for one minor but unexpected hurdle. The intention was
that the user should be able to power on any given devices that they want to
pair, and bring them within NFC range of each other in order to finish the
pairing, with no other interaction being necessary. This ended up not being
completely achievable in the current state of the proof-of-concept
40

implementation, due to NFC requiring one device to be an initiator, while the
other device is a target, in order to make communication between them
possible [30]. There are a few ways of solving this issue, which are explained
further in chapter 4.3. To summarize, the issue can be solved by requiring
some additional user interaction, for example by providing some instructions
with the devices telling the user to press a button on only one of the devices
in order to change the NFC role on that device. Alternatively, various forms of
automatic role selection can also be implemented, depending on what option
suits the IoT system in question. Even if the first option is chosen and an
additional action such as a button press is required, that should still be
considered fairly easy to use, since instructions for such a system can still be
printed on the device or elsewhere in just a few words. To summarize the
results with regards to the design goal of focusing on ease of use, the goal
was mostly achieved in the intended form in the proof-of-concept. With some
further development to remove the NFC role selection issue, the goal is
achievable in its entirety.
From a performance perspective, the system was capable of sending and
receiving a key pair consisting of 77 bytes, or 616 bits per key, with an
average speed of 980.8 milliseconds over three measurements, with a
maximum difference of 20.6 milliseconds between the shortest and longest
measured times. This time contains some significant overhead from
establishing the connection and processing the received data, so larger keys
will not increase the transfer time linearly. If we calculate the worst-case
scenario based on a linear increase in transmission time, the transfer speed,
including overhead, in this experiment was around 0.79 milliseconds per bit.
Exchanging a key pair with 2048-bit keys would thus take, at worst, 3260.8
milliseconds.
The goal of this project was to create a system for setting up secure network
communication using a decently secure pairing method between IoT devices
in environments where the user cannot be expected to have the knowledge

41

needed to set up and configure a more advanced system. The intention was
not to create a perfectly secure solution for every situation, since that is
practically impossible due to differing requirements in different use cases.
Generally speaking, the best security can be achieved by analyzing a specific
scenario, and manually choosing and configuring networks and devices to
suit the needs of that scenario. In situations where that is not an option, the
proposed NFC-pairing method achieves a decent level of security that should
cover many scenarios, and most importantly most domestic use cases,
without requiring any specialized knowledge. This NFC pairing should be
seen as a better alternative to having no security at all or an improperly
configured user-configurable system.

4.1. Observations on Random Number Generation

When generating random numbers on embedded devices, one will run into
issues trying to generate random numbers that are not easily predictable.
Computer operating systems generally provide a way of obtaining random
data, such as /dev/random and /dev/urandom in Linux [51]. These sources of
random data are based on noise from various hardware devices, and the
resulting data can then either be used directly, or to seed a random number
generator.
In embedded systems, one common convention for seeding random number
generators is to use the current time as a seed for the random number
generator. While that is fine for many purposes, where true randomness is
not too important, it is too predictable to be used as a source of random data
in cryptography. Additionally, many embedded devices lack a real time clock,
or RTC, which means that every single device will reset the clock to a given
42

default value, such as 0, when they are started. That, in turn, means that
every single device that boots and runs the same code will set up the clock
identically, which will lead to each device seeding the random number
generator with the same number. The result of that is that every device will
generate the same numbers in the same order, making encryption keys
generated using this data predictable. Even if a device has a functioning RTC
to keep the clock up to date, that still leads to fairly easily guessed random
data if the point in time at which an encryption key was generated is known.
The RTC could also be susceptible to attacks where the stored time is
manipulated or read by an attacker in order to change or know what data the
device uses to seed its random number generator. A better solution would
instead be to read some data from connected sensors, disconnected pins
and other similar sources of information.

This would provide somewhat

random data to use as a seed instead of using the system time. This
essentially emulates the behavior of /dev/random and /dev/urandom on Linux
on platforms where such random data sources are not natively available,
albeit

potentially

with

slightly

less

variability

depending

on

the

implementation.

4.2. Potential for Increased NFC Utilization

One of the drawbacks of the current proof-of-concept implementation of the
NFC-based pairing and authentication technology is that it only provides a
way of sharing information between devices during the pairing process.
Furthermore, the current implementation only exchanges public encryption
keys between the devices. In many systems, it would be beneficial to allow
for the transfer of much more information during the NFC pairing. For
example, if one of the paired devices has some configuration information that
43

the new device would benefit from, such as credentials for a wireless
network, this could be transferred to the new device during the pairing
process. This does still leave some situations where one would be unable to
send the configuration information to a device, such as when someone is
pairing two brand new devices that have yet to be set up. In those situations,
a smartphone application could further utilize the NFC capability of the IoT
devices in order to transfer the configuration information via NFC to the
device, since many modern smartphones include support for NFC [52]. This
would be preferable over solutions such as a web-based interface in
situations where physical security is better than the security of the network,
which is the case in many domestic use cases. On the other hand, it would
be a bad solution in scenarios where an unauthorized user could get physical
access to a device, as that would allow the attacker to reconfigure the device.
NFC-based device configuration could still be viable in such scenarios if it
required some form of authentication before allowing the user to make any
changes, but that would come with all the potential security issues associated
with user credentials.

4.3. NFC Mode for Initial Pairing

One issue affecting the ease of use of the NFC-based pairing solution that
came up during the development of the proof-of-concept code was that NFC
requires two devices with different roles. One of the NFC devices has to act
as the initiator, while the other device is the target which is merely waiting for
an initiator to appear and initiate a connection [30]. Because of this, there has
to be a way to set one of the devices that are being paired as the initiator
while the other one has to be set to be a target. In situations where one of the
devices that is being paired has already been previously paired to the NFC
44

network, this mode selection can be handled automatically. This automatic
selection can be done by making a device that has already been paired and
configured automatically assume one of the roles, say initiator, while devices
that have yet to be paired to any device automatically take on the other role,
which in this example would be the target role. This method of role selection
is not possible when the user wants to pair two brand new devices that have
yet to be paired to the IoT network, since they will both default to the same
state. Thus, the user has to take some form of action, such as pressing a
button on one of the devices, to make it switch to the other NFC role. It is
also possible to develop a system where both devices default to operating as
targets, but occasionally, at random intervals, switch to being initiators for a
short moment. This may cause some collisions where both devices happen
to switch to the initiator mode at the same time, but as long as the intervals
between attempts at being the initiator are actually random as well as being
sufficiently long, it should quickly lead to a situation where only one device
has switched to initiator while the other device is still listening as a target.
This method of role selection is illustrated in figure 7.

In the proof-of-concept implementation, this issue is handled by manually
changing a variable in the code that selects the NFC device role, and
compiling a separate version for the initiator and the target. Hard-coding the
NFC roles like this cannot be done in many real IoT systems, but there are
some situations where it is possible. In systems that are based on one
central hub-device, which all other devices will be paired to, the hub could
45

default to acting as, say, the initiator, while any devices that are intended to
be paired to the hub can be configured to act as targets, or the other way
around.

4.4. NFC Eavesdropping and Physical Access

While NFC does make eavesdropping and remote attacks more difficult than
with traditional wireless communication methods designed to work over
longer distances, it is still not immune to it, as noted in chapter 3.3.3. Due to
the short real world range of NFC, this is not a major risk factor in many
indoor, domestic use cases. In publicly accessible locations this could be a
more significant issue, especially if a potential attacker is able to get very
close to the IoT device implementing NFC. In such scenarios, some solution
needs to be implemented to ensure that the NFC transceivers are only
enabled when they are to be used to pair devices. Even so, eavesdropping is
still possible during the pairing itself when using NFC, so in some use cases
encrypting that communication will also be necessary. Generally speaking,
there are almost no drawbacks to encrypting the data being sent over NFC
by default, as long as memory and performance constraints allow for it.

4.5. Issues and Future Development

The software implementation used to prove NFC can be used to pair and
share data between IoT devices was designed to be used only as a proof-ofconcept, in order to test the viability of using NFC as a tool to pair IoT

46

devices. Thus, the code is not in a state where it would be ready to be used
in a production system without further development. This chapter is intended
to outline various issues that would require more development if the code
were to be brought up to the standards required to be used for anything more
than to prove that the technology works as intended.
As far as the security of the encryption is concerned, the current encryption
keys are calculated based on 16-byte, or 128-bit prime numbers, which are
generated using data from /dev/urandom which provides random data on
Linux [51]. While this provides for short encryption keys, which allows for
easy testing and debugging of the code, it does not provide sufficient security
for any practical encryption purposes. In order to make the keys difficult to
brute force, a key length of 2048 or 4096 bits is generally recommended at
the time of writing [23], although this may also be subject to change over time
as computers get faster and methods of breaking RSA encryption become
more sophisticated. Another encryption-related security concern is that the
current RSA implementation uses no padding scheme, which can lead to
ciphertexts that are short enough to be easily breakable [53]. Another
potential security concern is the entirely unencrypted NFC. Encrypting the
data that is being sent over NFC would be a good idea, since it would further
hamper any attempts at remote eavesdropping and certain other types of
attacks.
Random data from /dev/urandom is something that would most likely be
unavailable on most embedded devices that this technology could be
expected to run on. The easiest alternative of using a predetermined seed in
a simple random number generator would run the risk of always generating
the same prime numbers on every single device, every time they are booted.
There are some ways to avoid this issue, such as by basing the seed on the
current time. Unfortunately, that may also be unavailable at the pairing stage
unless the device has an internet connection or a clock that would allow it to
know the correct time, rather than defaulting to a known, predetermined

47

value. One remaining option is to use data from various sensors in the
device, or even noise from pins that are not connected to anything, as a seed
for a normal random number generator.
The code for the proof-of-concept implementation also has a number of
issues that would need to be addressed before the code can be used for
anything more than a proof-of-concept. Many of the buffers used for data in
the NFC, networking, encryption and decryption code use hard-coded sizes,
mostly 256 bytes. This limits the sizes of encryption keys, the length of
messages that can be sent and more. Some of the buffers need to have
known sizes unless the code is refactored, but this size could be provided
dynamically in the code or adapted to better suit the true requirements of a
given implementation. There are also several of these fairly large buffers that
could be refactored out of the code entirely, either by passing the data to
functions in a more efficient manner, or by reusing the same buffers for
multiple purposes rather than using multiple separate buffers. Since the
proof-of-concept was designed to be tested in a controlled environment,
minimal attention was paid to any type of input verification for data received
via the network or via NFC, other than ensuring that the data is technically
valid data. This means that any data sent over NFC will currently be
interpreted as an encryption key, and any valid packet received over the
network will be run through the decryption algorithm no matter who sent it or
what it contains. This can become an issue outside of a controlled
environment, since it has a significant negative impact on the stability and
security of the system.
There are also several features that are missing completely. Currently, the
system is not linking encryption keys to any particular device, and the code is
also limited to pairing two devices to each other. After this single pairing has
been done, the NFC transceivers currently shut down. This should at the very
least be modified so that the NFC code runs in its own thread, allowing
further device pairings beyond the one initial pairing. This would also require

48

a slightly more complex encryption key database to be created, as described
in the implementation chapter.
The intention for the network communication is that the system should check
the sender of a UDP multicast packet, recognize that the sender is online,
and try to respond with a TCP message that is encrypted using the senders
public key, assuming that the devices have been paired and the public key of
the other device is known. Currently, the devices use the UDP multicast
protocol, which is intended to be used only for network discovery protocol
communication, to broadcast data encrypted using the one public key the
devices have received via NFC. The digital signature implementation is also
currently missing, since it was not necessary in order to prove the viability of
the NFC pairing. It would, however, be a critical part of a production
implementation of the NFC-based pairing method.
Currently, the code also lacks a way of dynamically making one device the
NFC initiator and the other one the target. There is a variable that is used to
select the role, which can be changed with a button or other method in the
future, but currently the code has to be compiled separately for both devices,
with the variable being hard-coded to select the correct role. Another missing
feature is the peer to peer encryption key sharing, which is missing due to the
proof-of-concept not yet being able to handle more than two devices being
paired at any given time. This is also a feature that would only be useful in
systems where every device needs to be able to communicate with every
other device in the IoT system, which is only the case in a limited number of
use cases.

5. Conclusions

49

As previously stated, there is a clear need for security in IoT pairing, since
commonly used solutions tend to make compromises in security in the name
of usability, or alternatively they compromise usability to improve security.
Many IoT systems make it possible to pair devices wirelessly and almost, or
entirely, without any user interaction, which may also leave said pairing open
to others than the intended users or devices. Alternatively, more advanced
IoT systems may utilize pairing methods that are more secure but too
complicated for the average user to use. Thus, a solution that combines ease
of use with a decent level of security in its default state would be an
improvement over the currently favored easy to use but insecure solutions.
NFC-based IoT device pairing and authentication allows for easy pairing,
only requiring that users bring the devices very close to each other, in order
to allow them to exchange encryption keys and set up secure network
communication with one another. The need for physical action and close
proximity between the devices, a consequence of the low range of NFC,
removes the ambiguity of which devices the user wants to pair, warding off
remote attacks on the pairing interface. The fact that the devices configure
themselves without further user interaction also avoids any potential
configuration issues from being inadvertently caused by the user.
Testing of the proposed NFC-based pairing method showed that it is a
technologically viable option. With some further development of the proof-ofconcept implementation, as detailed in chapter 4.5, NFC-based pairing and
authentication could easily be adapted for use in production systems.

50

6. Summary in Swedish – Svensk
sammanfattning
Närfältskommunikation för användarcentrerad
parning och autentisering av IoT-enheter

Introduktion

Tack vare teknikens snabba utveckling är en internetanslutning inte längre en
egenskap som är begränsad till traditionella datorer. Numera kan många
elektroniska enheter av andra slag kopplas till internet, och dessa enheter
sägs höra till sakernas internet, mera känt under namnet ”IoT”, som kommer
från från engelskans ”Internet of Things”. Då dessa IoT-enheter behöver
kommunicera med varandra över ett lokalt nätverk, så behövs det någon
metod för att para ihop dessa enheter. Detta är nödvändigt, eftersom
enheterna på något sätt måste bli medvetna om varandras existens och att
det är meningen att de ska kommunicera med varandra. Många av de
parningsmetoder, som i dagens läge används för att para ihop IoT-enheter,
lider dock av säkerhetsproblem. Detta beror ofta på att enheternas tillverkare
väljer att prioritera användarvänligheten på datasäkerhetens bekostnad.
Syftet med denna avhandling är att introducera och testa en metod för
parning av IoT-enheter som utnyttjar närfältskommunikation. I fortsättningen
kallas detta ”NFC”, av engelskans ”Near Field Communication”. Designmålen
för detta projekt är att teknologin ska kunna erbjuda en synnerligen
användarvänlig upplevelse, som endast kräver att användaren flyttar två IoT51

enheter, som ska paras ihop, på några millimeters avstånd från varandra.
Därutöver är avsikten även att den NFC-baserade parningsmetoden ska
erbjuda tillräcklig datasäkerhet för hemmabruk utan att kräva någon som
helst användarkonfiguration.

Bakgrund

Det finns ett antal faktorer som påverkar datasäkerheten både i IoT-system
och i mera traditionella datorsystem. Det är dock ett välkänt faktum inom
datasäkerhetsbranschen att användarna av systemet utgör den största
säkerhetsrisken [5]. Det är vanligt att användarna saknar tillräcklig kunskap
för att identifiera och motverka säkerhetsproblemen, vilket betyder att osäkra
lösenord och systemkonfigurationer förblir i användning. Därtill kan
användarnas okunskap utnyttjas i attacker där social manipulation används
för att exempelvis få användarna att klicka på länkar eller ge ut sina lösenord.
Social manipulation används i hela 98 procent av alla attacker mot it-system
[5]. Genom att automatiskt sköta om parningen och den säkerhetsrelaterade
konfigurationen

av

IoT-enheterna,

så

avser

den

IoT-baserade

parningsmetoden att minimera den påverkan som användarens val kan ha
på systemets säkerhet.
I dagens läge används ett stort antal olika parningsmetoder i IoT-system. En
av de vanligaste metoderna är en helt automatiserad parning över nätverket
genom att använda något upptäcktsprotokoll som låter enheterna finna
varandra på nätverket. Denna metod medför dock en väldigt låg
säkerhetsnivå, då vilka som helst potentiellt skadliga enheter som kopplats till
nätverket kan kommunicera med de övriga enheterna. En annan populär
52

parningsmetod är att använda sig av någon trådlös form av kommunikation,
till exempel Bluetooth. I en sådan parningsmetod meddelar en enhet att den
finns tillgänglig via den valda kommunikationsmetoden, vilket låter andra
enheter koppla upp sig till den. Den metoden lider dock även av att vem som
helst inom den trådlösa kommunikationens räckvidd kan koppla upp sig till
enheten

då

parningsläget

är

påkopplat.

Den

NFC-baserade

parningsmetoden fungerar på många sätt liksom den ovan beskrivna trådlösa
parningen, men NFC-teknologin har en fördel i och med att dess räckvidd är
begränsad till endast ett fåtal centimeter [19]. Detta innebär att användaren
fysiskt måste välja vilka enheter som får paras ihop, genom att placera dem
bredvid varandra.

Metodik

För att testa om NFC-baserad parning och autentisering är ett tekniskt
fungerande alternativ till andra tekniker som används för samma syfte, så
skapade jag en prototyp för att representera en verklig implementation av
systemet. Programvaran som sköter om kommunikationen över NFC, och
nätverkskommunikationen

mellan

enheterna

efter

parningen,

programmerades i programmeringsspråket C++. Programvaran testades
sedan på fysisk hårdvara, bestående av två Raspberry Pi-prototypkort [36],
kopplade till samma nätverk. Prototypkorten kopplades även till varsin PN532
NFC-sändtagare [36][38] för att möjliggöra en NFC-kommunikation mellan
dem. Efter att prototypen var byggd, så testades den, och resultaten
utvärderades för att se om systemet uppfyllde designmålen eller inte.
Själva den NFC-baserade parningen sker genom att de två enheterna som
53

ska paras ihop förs inom varandras NFC-räckvidd. Då detta har gjorts, kan
enheterna överföra sina publika krypteringsnycklar och övrig nödvändig
information till varandra via NFC. Då överföringen slutförts, kan enheterna
börja skicka krypterade meddelanden till varandra genom att utnyttja RSAkryptering [26]. Detta sker genom att en enhet krypterar informationen, som
ska skickas till en annan enhet, med mottagarens publika nyckel, vilken
tidigare överförts över NFC. Därefter kan endast mottagaren dekryptera
meddelandet med hjälp av sin privata nyckel. Genom att utnyttja digitala
signaturer[29], kan mottagaren även verifiera att meddelandet verkligen
skickats av en enhet som den tidigare parats till.

Resultat

Testningen av prototypen visade att NFC-baserad parning av IoT-enheter är
en teknik som kan implementeras utan större hinder. Det enda oväntade
problem som upptäcktes i implementeringsfasen var att NFC kräver att de
två enheterna som ska kommunicera med varandra ska ha olika så kallade
roller. Den ena enheten ska ha en roll, som kallas ”initiator”, och dess uppgift
är att driva RF-fältet som används för kommunikationen. Samma enhet
skickar även ut meddelanden som den andra enheten, vars roll kallas
”target”, sedan svarar på [30]. Detta kan i vissa situationer vara ett problem,
eftersom två identiska enheter som ska paras ihop måste ha ett sätt för att
veta, vilken roll de ska ha. Det här valet av roller går att lösa på ett antal sätt,
till exempel genom att båda enheterna väljer ”target”-rollen, och sedan med
slumpmässiga tidsintervaller byter roll till ”initiator” och försöker starta
kommunikationen med den andra enheten. Bortsett från detta problem
uppfyllde prototypen för NFC-baserad parning och autentisering alla

54

designmål för projektet.

Konklusion

Sammanfattningsvis kan det konstateras att NFC-baserad parning är en
tekniskt välfungerande teknologi. Med en viss mängd vidareutveckling av
prototypen

kunde

den

användas

som

en

ersättare

för

andra

parningsmetoder. Parningsmetoden kombinerar användarvänlighet med en
tillräcklig säkerhetsnivå för hemmabruk, och möjliggör trådlös parning av IoTenheter med minimal användarinteraktion.

55

References
[1]

F. Dahlqvist, M. Patel, A. Rajko and J. Shulman, “Growing
opportunities in the Internet of Things”, 22.7.2019. [Online]. Available:
https://www.mckinsey.com/industries/private-equity-and-principalinvestors/our-insights/growing-opportunities-in-the-internet-of-things.
(accessed 2.2.2021)

[2]

Nokia, “Nokia Threat Intelligence Report – 2019”, Nokia, 2019. [Online].
Available: https://pages.nokia.com/T003B6-Threat-Intelligence-Report2019.html. (Accessed 20.3.2021)

[3]

R. Karlsson, “NFC-baserad nätverksautentisering för IoT-enheter”,
Bachelor’s thesis, faculty of Science and Engineering, Åbo Akademi
University, Turku, Finland, 2019.

[4]

P. Rodwald, “Attack on Students’ Passwords, Findings and
Recommendations”, in Corporate Social Responsibility and Corporate
Change, 2020, pp.425-434. [Online]. Available: www.researchgate.net/
publication/333039219_Attack_on_Students ’_Passwords_Findings_and
_Recommendations. (Accessed 26.2.2021)

[5]

“2021 Cyber Security Statistics: The Ultimate List Of Stats, Data &
Trend”, PurpleSec. [Online]. Available:
https://purplesec.us/resources/cyber-security-statistics/. (Accessed:
10.2.2021)

[6]

“What is Phishing?”, Cisco. [Online]. Available: https://www.cisco.com/c/
en/us/products/security/email-security/what-is/phishing.html. (Accessed:
20.3.2021)

[7]

K. Shipulin, “Practical ways to misuse a router”, Positive Technologies,
16.6.2017. [Online]. Available:
https://blog.ptsecurity.com/2017/06/practical-ways-to-misuse-router.html.
(Accessed: 26.2.2021)

[8]

A. Adams and M. A. Sasse, “USERS ARE NOT THE ENEMY”,
56

Department of Computer Science, University College London. [Online].
Available: https://discovery.ucl.ac.uk/id/eprint/20247/2/CACM
FINAL.pdf. (Accessed: 26.2.2021)
[9]

“Social Engineering: How the Himan Factor puts your Company at
Risk”, Positive Technologies, 2018. [Online]. Available:
https://www.ptsecurity.com/upload/corporate/ww-en/analytics/Socialengineering-2018-eng.pdf. (Accessed: 10.2.2021)

[10] D. Bohn, "Google can't fix the Android update problem", The Verge,
4.9.2019. [Online]. Available:
https://www.theverge.com/2019/9/4/20847758/google-android-updateproblem-pie-q-treble-mainline. (Accessed: 2.3.2021)
[11] "Modular System Components", Android Open Source Project. [Online].
Available: https://source.android.com/devices/architecture/modularsystem. (Accessed: 2.3.2021)
[12] " Good Practices for Security of Internet of Things in the context of
Smart Manufacturing", European Union Agency for Cybersecurity,
19.11.2018. [Online]. Available:
https://www.enisa.europa.eu/publications/good-practices-for-security-ofiot. (accessed: 2.3.2021)
[13] A. M. Lonzetta, P. Cope, J. Campbell and B. J. Mohd, "Security
Vulnerabilities in Bluetooth Technology as Used in IoT" in Journal of
Sensor and Actuator Networks 7(3):28, 19 july 2018, DOI:
10.3390/jsan7030028. Available:
https://www.researchgate.net/publication/326511381_Security_Vulnera
bilities_in_Bluetooth_Technology_as_Used_in_IoT. (Accessed:
2.3.2021)
[14] M. Covington and R. Carskadden, “Threat implications of the Internet of
Things” in 2013 5th International Conference on Cyber Conflict (CYKON
2013), 2013. Available: https://ieeexplore.ieee.org/document/6568380.
(Accessed: 20.3.2021)
[15] S. Weisman, "What is a distributed denial of service attack (DdoS) and
57

what can you do about them?", Norton, 23.7.2020. [Online]. Available:
https://us.norton.com/internetsecurity-emerging-threats-what-is-a-ddosattack-30sectech-by-norton.html. (Accessed: 2.2.2021)
[16] "Research Reveals Hacker Tactics: Cybercriminals Use DDoS as
Smokescreen for Other Attacks on Business", Kaspersky, 22.11.2016.
[Online]. Available:
https://www.kaspersky.com/about/press-releases/2016_researchreveals-hacker-tactics-cybercriminals-use-ddos-as-smokescreen-forother-attacks-on-business. (Accessed: 2.1.2021)
[17] K. Chivers, "What is a man-in-the-middle attack?", Norton, 26.3.2020.
[Online]. Available: https://us.norton.com/internetsecurity-wifi-what-is-aman-in-the-middle-attack.html. (Accessed: 2.1.2021)
[18] E. D. Cardenas, "MAC Spoofing—An Introduction" , Global Information
Assurance Certification, 23 august 2003. [Online]. Available:
https://www.giac.org/paper/gsec/3199/mac-spoofing-an-introduction/
105315. (Accessed: 20.3.2021)
[19] "About the technology", NFC forum. [Online]. Available: https://nfcforum.org/what-is-nfc/about-the-technology. (Accessed: 20.3.2021)
[20] "2017 Cybersecurity Threat Insights Report for Leaders: Partnering to
Fight Cybercrime", Secureworks, 2017. [Online]. Available:
https://www.secureworks.com/resources/rp-cybersecurity-threatinsights-2017. (Accessed: 17.3.2021)
[21] D. Legezo, "Research on unsecured Wi-Fi networks across the world",
SECURELIST by Kaspersky, 24.11.2016. [Online]. Available:
https://securelist.com/research-on-unsecured-wi-fi-networks-across-theworld/76733. (Accessed: 2.3.2021)
[22] M. J. Stauffer, "Principles of Cryptography" in Cyberspace Principles
Course, 1.6.2019. [Online]. Available:
https://cap-cdta.gitbook.io/cyberspace-principles-course/table-ofcontents/principles-of-cryptography. (Accessed: 20.3.2021)
[23] E. Barker and Q. Dang, "Recommendation for Key Management, Part
58

3: Application-Specific Key Management Guidance", National Institute
of Standards and Technology, 2015. [Online]. Available:
https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.80057Pt3r1.pdf. (Accessed: 27.1.21)
[24] M. B. Yassein, S. Aljawarneh, E. Qawasmeh, W. Mardini and Y.
Khamayseh, "Comprehensive study of symmetric key and asymmetric
key encryption algorithms" in 2017 International Conference on
Engineering and Technology (ICET), Antalya, Turkey, 2017, pp. 1-7,
DOI: 10.1109/ICEngTechnol.2017.8308215. Available:
https://ieeexplore.ieee.org/document/8308215. (Accessed: 17.3.2021)
[25] "Best Practices for Client Side Encryption", CSC – IT CENTER FOR
SCIENCE LTD., 19.12.2019. [Online]. Available: https://research.csc.fi/
best-practices-for-client-side-encryption. (Accessed: 20.3.2021)
[26] R.L. Rivest, A. Shamir and L.Adleman, "A Method for Obtaining Digital
Signatures and Public-Key Cryptosystems", 1977. [Online]. Available:
https://people.csail.mit.edu/rivest/Rsapaper.pdf. (Accessed: 17.3.2021)
[27] M. Nemec, D. Klinec, P. Svenda and P. Sekan, "Measuring Popularity
of Cryptographic Libraries in Internet-Wide Scans" in the 33rd Annual
Computer Security Applications Conference, 2017, pp. 162-175, DOI:
10.1145/3134600.3134612. Available:
https://www.researchgate.net/publication/321505941_Measuring_Popul
arity_of_Cryptographic_Libraries_in_Internet-Wide_Scans. . (Accessed:
20.3.2021)
[28] M. Cobb, "RSA algorithm (Rivest-Shamir-Adleman). [Online]. Available:
https://searchsecurity.techtarget.com/definition/RSA. (Accessed:
0.1.2021)
[29] K. Levasseur, "Digital Signatures using RSA", 2013. [Online]. Available:
http://faculty.uml.edu/klevasseur/math/RSA_Signatures/RSA_Signature
s.pdf. (Accessed: 8.12.2020)
[30] Information Technology – Telecommunications and information
exchange between systems – Near Fiend Communication – Interface
59

and protocol (NFCIP-1), International Standard ISO/IEC 18092:2013,
2013. [Online]. Available:
https://standards.iso.org/ittf/PubliclyAvailableStandards/c056692_ISO_I
EC_18092_2013.zip. (Accessed 14.1.21)
[31] E. Desai and M. G. Shajan, "A Review on the Operating Modes of Near
Field Communication" in International Journal of Engineering and
Advanced Technology (IJEAT), vol. 2, no. 2, December 2012, ISSN:
2249-8958. Available: https://www.ijeat.org/wp-content/uploads/papers/
v2i2/B0956112212.pdf. (Accessed: 14.1.2021)
[32] C. Xinru, "Information Security of Apple Pay", Business Information
Technology, Oulu University of Applied Sciences, Oulu, Finland, 2016.
[Online]. Available:
https://www.theseus.fi/bitstream/handle/10024/118948/Chen_Xinru.pdf.
(Accessed: 21.3.2021)
[33] C. Bettstetter and C. Renner, "a comparison of service discovery
protocols and implementation of the service discovery protocol",
Institute of Communication Networks, Technische Universität München,
Munich, Germany, 2000. [Online]. Available:
https://dl.ifip.org/db/conf/ifip6-6/eunice2000/paper5-1.pdf. (Accessed:
8.12.2020)
[34] "UpnP Device Architecture 2.0", Open Connectivity Foundation, Inc.,
17.4.2020. [Online]. Available: https://openconnectivity.org/upnp-specs/
UpnP-arch-DeviceArchitecture-v2.0-20200417.pdf. (Accessed:
30.1.2021)
[35] R. Droms, "Dynamic Host Configuration Protocol", Network Working
Group, March 1997. [Online]. Available:
https://tools.ietf.org/html/rfc2131. (Accessed: 17.3.2021)
[36] "Teach, Learn and Make with Raspberry Pi", Raspberry Pi Foundation.
[Online]. Available: https://www.raspberrypi.org. (Accessed: 21.3.2021)
[37] "Grove – NFC", Seeed Technology Ltd. [Online]. Available:
https://wiki.seeedstudio.com/Grove_NFC/. (Accessed: 21.3.2021)
60

[38] "PN532/C1: Near Field Communication (NFC) controller", NXP
Semiconductors, 28 November 2017. [Online]. Available:
https://www.nxp.com/docs/en/nxp/data-sheets/PN532_C1.pdf.
(Accessed: 17.3.2021)
[39] F. Durda, "Serial and UART Tutorial", 8.1.2021. [Online]. Available:
https://docs.freebsd.org/en_US.ISO8859-1/articles/serial-uart/.
(Accessed: 21.3.2021)
[40] S. Evanczuk, "2019 Embedded Markets Study reflects emerging
technologies, continued C/C++ dominance", 24.11.2019. [Online].
Available: https://www.embedded.com/2019-embedded-markets-studyreflects-emerging-technologies-continued-c-c-dominance/. (Accessed:
10.2.2021)
[41] "Fundamental types". [Online]. Available:
https://en.cppreference.com/w/cpp/language/types. (Accessed:
21.3.2021)
[42] "The GNU MP Bignum Library". [Online]. Available: www.gmplib.org .
(Accessed: 15.1.21)
[43] "Platform independent Near Field Communication (NFC) library".
[Online]. Available: https://github.com/nfc-tools/libnfc. (Accessed:
15.1.21)
[44] J. Finnis, "C++/C code to send UDP packets", 4.10.2013. [Online].
Available: https://gist.github.com/jimfinnis/6823802. (Accessed:
6.9.2020)
[45] "Simple listener and sender for UDP multicast", Feb 15, 2017. [Online].
Available:
https://gist.github.com/hostilefork/f7cae3dc33e7416f2dd25a402857b6c
6. (Accessed: 6.9.2020)
[46] H. S. Kortvedt and S. F. Mjølsnes, "Eavesdropping Near Field
Communication". [Online]. Available:
https://www.researchgate.net/publication/265976861_Eavesdropping_N
ear_Field_Communication. (Accessed: 22.11.2020)
61

[47] "Qualification Fees", Bluetooth SIG, Inc. [Online]. Available:
https://www.bluetooth.com/develop-with-bluetooth/qualification-listing/
qualification-listing-fees/. (Accessed: 21.3.2021)
[48] T. Bray, "The JavaScript Object Notation (JSON) Data Interchange
Format", Internet Engineering Task Force (IETF), December 2017.
[Online]. Available: http://tools.ietf.org/html/rfc8259. (Accessed:
21.3.2021)
[49] Y. Shafranovich, "Common Format and MIME Type for CommaSeparated Values (CSV) Files", The Internet Society, October 2005.
[Online]. Available: https://tools.ietf.org/html/rfc4180. (Accessed:
21.3.2021)
[50] R. Schollmeier, "A definition of peer-to-peer networking for the
classification of peer-to-peer architectures and applications" in
Proceedings First International Conference on Peer-to-Peer Computing,
2001, DOI: 10.1109/P2P.2001.990434. [Online]. Available:
https://ieeexplore.ieee.org/document/990434?arnumber=990434.
(Accessed: 19.2.2021)
[51] "random, urandom – kernel random number source devices", Linux
Manual Page, 15.9.2017. [Online]. Available:
https://man7.org/linux/man-pages/man4/random.4.html. (Accessed:
10.2.2021)
[52] J. Carvalho, "Fresh SmartPhone Statistics And What They Mean For
You, NFC And The World", December 4, 2019. [Online]. Available:
https://nfc-forum.org/fresh-smartphone-statistics-and-what-they-meanfor-you-nfc-and-the-world/. (Accessed: 22.3.2021)
[53] S. Gurumurthy, "Network Security" in Proceedings of the World
Congress on Engineering 2010 Vol I, WCE 2010, 2010, London, U.K.
[Online]. Available:
https://www.academia.edu/27123698/Network_Security. (Accessed:
22.3.2021)

62

Appendices
R. Karlsson, Source code for the proof-of-concept implementation of NFCbased

pairing

and

authentication.

[Online].

https://github.com/razemuze/nfc-iot-pairing. (Accessed: 29.3.2021)

63

Available:

