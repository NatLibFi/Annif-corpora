Security Testing of RESTful Web APIs with
RESTler

Master’s Thesis in Information Technology
Supervisor: Prof. Ivan Porres
Study program in Computer Engineering
Faculty of Science and Engineering
Srijan Chapagain 1901645
2020-2021

Abstract
Web Application Programming Interfaces (APIs) consist of one or many endpoints
defining request-response architecture. Modern Web APIs follow the Representational
State Transfer (RESTful) architecture which is accessible to the clients through
Hypertext Transfer Protocol (HTTP) interactions. Security testing is a process to reveal
flaws in the security mechanism of the system that protect data and maintain the
functionality of the system. The oracle problems like distinguishing correct from
incorrect behavior is suffering and it is manually impractical to handle, which can be
prevented with a good security testing process. The adequate security testing process
involves checking various aspects of the system like authentication, authorization,
confidentiality, availability, integrity, resilience and so on.
This thesis extends a tool “RESTler”, which is the first stateful REST API fuzzing tool to
automate the cloud services testing and finding security and reliability bugs in the
system. The extension includes Metamorphic Relation Output Patterns (MROPs) that
capture desired properties of REST APIs. This thesis showcases how to extend a
fuzzing tool with active property checkers, which as a whole automates the testing of
security related issues. The checkers follow a metamorphic testing approach which
uses target function or also known as metamorphic relations to generate follow-up test
cases and verify it automatically. This approach eliminates the oracle problems like
determining the correct output for a given input.

Table of Contents
Abbreviations

5

Introduction
Problem Statement and Research Question
Objectives
Structure of the thesis

1
1
2
3

Background
RESTful Web APIs
Fuzz Testing
Metamorphic Testing
Metamorphic Relation Output Patterns
Equivalence
Equality
Subset
Disjoint
Complete
Difference
Related Works
RESTler: Stateful REST API Fuzzing
Checking Security Properties of Cloud Service REST APIs
Metamorphic Security Testing for Web Systems

5
5
6
7
8
9
9
10
10
10
11
11
11
12
13

RESTler
Introduction
Processing OpenAPI Specifications
Main Algorithm
Authentication
Extending RESTler
Current Limitations

14
14
16
20
22
22
24

Design and Implementation
Implementation
Current Case Study
Implementation of Metamorphic Relation Output Patterns
Equivalence
Equality

25
25
25
31
31
35

Subset
Disjoint

39
43

Evaluation and Discussion
Testing
Bug Seeding
Discussion

47
47
48
51

Conclusions and Future Work
Conclusions
Future work

52
52
53

References

53

Abbreviations
REST Representational State Transfer
HTTP Hypertext Transfer Protocol
API Application Programming Interface
CRUD Create, Read, Update, and Delete
URI Uniform Resource Identifier
JSON JavaScript Object Notation
XML Extensible Markup Language
XHTML EXtensible HyperText Markup Language
YAML Yaml Ain't Markup Language
SOAP Simple Object Access Protocol
MR Metamorphic Relation
GCC GNU Compiler Collection
OWASP Open Web Application Security Project
DSL Domain-Specific Language
SMRL Security Metamorphic Relation Language
MROP Metamorphic Relation Output Pattern

1. Introduction
Modern IT infrastructures are based on concepts like cloud computing, web services, or
social networking, which are connected to other systems to handle sensitive data. A
large part of the security breaches are caused by attackers who exploit vulnerable
systems. An effective measure to prevent the security of the system is by applying
security testing to identify vulnerabilities and provide secured functionality [1].
The focus of the thesis is on the web services that are accessed through REST APIs.
The REpresentational State Transfer (REST) API is an application programming
interface (API) that follows the REST architectural style and allows for interaction with
RESTful web services [2]. In other words, an API helps to maintain the communication
between the clients and the web services. The main goal of this thesis is to extend
RESTler with activity property checkers to increase the security of the system. RESTler
consists of four security rules to test and detect the violations. But, in this thesis, the
focus is to modify those rules which follow a metamorphic approach of testing. The
approach will implement Metamorphic Relation Output Patterns (MROPs) to perform the
test on the system under test.
Github repository, forums, different research papers of the tool were the general
supports during the development and documentation phase.

1.1.

Problem Statement and Research Question

Testing Web APIs are crucial, but challenging due to its unpredictability in different
responses to a given input i.e oracle problem. Some of the major security threats for
REST APIs are Injection Attacks, Broken Authentication, Sensitive Data Exposure,
Broken Access Control, Parameter Tampering. So, the question on how secure it is, is

1

still widely open. Some major tools available for testing REST APIs are based on
capturing live traffic, then parse, fuzz and replay the traffic, aiming to find bugs [3]–[7].
Recently, researchers at Microsoft have extended RESTler with active property
checkers to improve the security testing of REST APIs [8]. The extended version
introduces four different security rules that capture different properties of REST APIs to
prevent security related issues. The checkers are implemented in a modular way, which
does not let checkers interfere among themselves and finds violations beyond the HTTP
errors but with limited knowledge of the expected output. The major issue with the
implemented method is that it has no logical pattern and in most cases it generally finds
simple faults.
How to implement metamorphic relations in the rules defining checkers?

1.2.

Objectives

RESTler, the first stateful fuzzing tool provides an automatic cloud service testing
through the given REST APIs services [9]. However the bugs found by the tool are
either the ones with status code 500 or those triggered by the checkers. The challenge
here is that it is hard to find specific logic bugs such as resource leaks or other
violations.
In this thesis, a new set of active property checkers will be developed using a
metamorphic approach for RESTler. The results will then be compared to original
checkers which are readily available with RESTler. The fifth chapter includes the results
and evaluation of both methods. The objective of the thesis is to improve the tool by
implementing a metamorphic approach and check its efficiency. The current working
method compiles the swagger specification file, which is an API description format for
REST APIs to a grammar file and returns a bug if something with status code 500 is
found, but the proposed method follows a metamorphic approach, which compares the
Metamorp after generating the grammar file i.e, comparing the source output against
the follow-up output. The current working and the proposed working method for

2

RESTler differ in the execution and assertion of the grammar file (Fig 1.2). In the
proposed approach, the swagger specification, which is an API description format for
REST APIs will be process by RESTler’s compiler and the generated

Fig 1.2:Current working vs proposed working method for RESTler

1.3.

Structure of the thesis

The rest of the thesis is divided into five more chapters. Chapter 2 introduces the
background of the thesis including concepts of RESTful Web APIs, RESTler,
Metamorphic Testing, MROPs. The following chapter includes related works and covers
three different papers covering RESTler and Metamorphic security testing. Chapter 4
includes the main part of the thesis which is the implementation of the MROPs. It covers
methodology, on how to use the tool itself, case study and the detailed implementation

3

of the patterns. The findings and results from the new approach and its comparison with
older methods is done in chapter 5. The final chapter 6 summarizes the work, revise the
research questions and the improvements which can be done in the near future.

4

2. Background
Modern IT systems are vulnerable to numerous attacks and so are Web services like
REST. To generalize the understanding of them, this section presents basics to
understand the RESTful Web APIs, RESTler with active property checkers and
Metamorphic testing.

2.1.

RESTful Web APIs

The REpresentational State Transfer (REST) is an architectural style which uses a
subset of HTTP. Modern interactive applications that use web services follow RESTful
style. It provides the web resources in a textual representation, which implements one
or more CRUD operations.
Resources are typically identified by a Uniform Resource Identifier (URI) and are
accessible and manipulable using an HTTP protocol. REST is an alternative to SOAP
as a way to access Web service [10]. An API endpoint is an unique URI to identify the
resources. RESTful Web APIs follow a design guidelines that includes some of the
standard HTTP methods like [11], [12] :
● GET: To read a resource.
● POST: To create a resource. On a successful execution, returns the created
resource.
● PUT: To update a resource. On a successful execution, returns the updated
resource.
● PATCH: To update a resource partially. On a successful execution, returns the
updated resource.
● DELETE: To delete a resource.
As an example, “GET https://www.googleapis.com/blogger/v3/blogs/blogId”, this
request returns a particular blog with the “blogID''. The URI shows the blog with the

5

“blogID'' identifier, and the HTTP method (GET) specifies the read operation. URIs can
include additional parameters like filtering, ordering, and pagination.
Resources can be represented in different formats such as JSON, XML, XHTML, YAML.
In this project, JSON is used as the preferred choice, because it is lightweight,
human-readable which is composed of data-property pairs. Fig. 2.1 shows the resulting
JSON data from blogger API, the data consists of strings, objects (delimited with curly
braces), arrays (delimited with square braces) and references to other API endpoints
like “selfLink” in “Pages” to navigate from one endpoint to another.

Fig 2.1: JSON representation of a blog in Blogger

2.2.

Fuzz Testing

Fuzz testing is an approach to find security vulnerabilities in software systems by
generating and feeding random inputs, which capture abnormal behaviors such as

6

program crash [13] There are generally three main categories of fuzzing techniques:
black-box, gray-box and white-box fuzzing [14].
Black-box fuzzing generates inputs without the knowledge of the internal behavior or
implementation. It is applicable in scenarios when the target is large and slow, is not
deterministic for the same input, or the system is complicated. Peach is one of the
popular black-box fuzzer tools [15].
Gray-box fuzzing leverages program instrumentation rather than the program analysis
to get feedback, which steers the fuzzer. But this type of fuzzing is highly inefficient if
applied to input-dependent systems. Existing gray-box fuzzing tools are American fuzzy
lop, LibFuzzer, and Honggfuzz [16]–[18].
White-box fuzzing leverages program analysis to improve the code coverage or to reach
critical locations within the program. It uses the program’s specification to generate
inputs and check the program outputs against the given specification. This method is
really helpful in exposing bugs that hide deep in the system. However, the time used
can be relatively long. An example of the tool using this method is SAGE which
leverages symbolic execution to explore different paths in the system [19].

2.3.

Metamorphic Testing

Metamorphic Testing is a testing approach which enables engineers to specify
Metamorphic Relations (MRs) that capture security properties of the system and
helps to alleviate the oracle problem in security testing [20]. The oracle problem
refers to difficulties in checking actual and expected API responses while testing
Web APIs. This testing approach provides an alternative when the expected
output of a test execution is complex or unknown [20]. In metamorphic testing,
multiple executions of programs under test are checked against certain
properties called Metamorphic Relations (MRs). A metamorphic relation is a

7

property that holds between two or more input data and their output of the
program.
Given a program A and a test case t1, the output is denoted by A(t1) and another
test case t2 with output A(t2). A number of test cases t1, t2, t3 …., tn is
constructed based on input-output pair (tn, A(tn)) to find errors linked with
program A. For instance, consider the metamorphic relation in Google’s Blogger
API as: two searches for posts with the same query should return the same
number of total results regardless of pagination or sorting. The relation basically
means that a new search is performed with a sample query which returns 27 total
posts while the results per page is 20, but as soon as the page size is changed,
the total result also changes. This is an example of a reproducible fault which is
detected by a metamorphic approach.
Chen et al. introduced Metamorphic Testing back in 1988 in an approach to
reuse existing test cases [20]. The use of metamorphic testing has expanded
hugely over the past years in numerous domains like Web services and
applications, computer graphics, cyber security and some other modern tools like
Google search engine and compiler GCC (GNU Compiler Collection) [21].

2.4.

Metamorphic Relation Output Patterns

The task of identifying metamorphic relations on a system under test is manual
and time consuming. A mostly used approach to identify the metamorphic
relations is to check the system’s manual and manually predict the change in the
output for a modified input [21]. Considering the amount of manual interceptions
and efforts this approach requires is high and tedious for a bigger system under
test. Segura et al. presented six different Metamorphic Relation Output Patterns
(MROPs) that capture different forms of metamorphic relations found in RESTful
Web APIs [21].

8

MROP describes an abstract output relation for a variety of input relations
consisting of typical http protocols like GET, POST, PUT, DELETE and so on. The
input relations can be formed by performing adding, removing or changing
parameters of the resources in a certain way. The input relations can be
combined to instantiate a MROP which satisfies one or more metamorphic
relations on the API under test.
The proposed patterns can be implemented only on the REST architectural
design and the system under test presumably implements CRUD operations.
Based on the definition of metamorphic relations for metamorphic testing in the
previous section, an input-output pair is created as such (S, F1, F2, .., Fn) and
MROP provides an expression for those pairs which satisfies certain patterns.
Below mentioned are six different MROPs which will be discussed briefly and
later in the design and implementation section will be discussed thoroughly on
how it works for the system under test. Google’s blogger API is taken as
reference to describe the MROPs.

2.4.1.

Equivalence

As simple as the word interprets, the equivalence pattern represents those
relations where the source and follow-up output(s) are equivalent irrespective of
other parameters such as filtering and pagination, i.e, S ≡ Fn. For instance, a
change in order should still provide equivalent outputs. Thus, a search with
keyword “my blog” in Google’s blogger should return the same blogs regardless
of the filtering parameters like date, rating, relevance or title.

2.4.2.

Equality

Almost close to the equivalence pattern, this pattern represents those relations
where the source and follow-up output(s) must contain the same items and in the
same order also, i.e., S = Fi. For example, a search in Google’s blogger with no

9

page size should produce the same result as indicating the default maximum
number of results to return (limit=10).

2.4.3.

Subset

This pattern groups the relations where the follow-up outputs should be subsets
of the source output, i.e., S ⊇ F1 ⊇ F2 ⊇ . . . ⊇ Fn. For example, a search in
Google’s blogger with limit per page of 20 should produce the subset of the result
with limit per page of 50. This can be generalized in common query search
operators also, for instance, a search query with “science OR technology” and a
follow-up test case with the keyword “science”. The follow-up should be a subset
of the source output.

2.4.4.

Disjoint

The relation where the intersection among the source and follow-up outputs is
empty is regarded as disjoint, i.e, S ∩ Fi = ∅ . For example, a search query for
blog posted with title “ A new era with science” and a follow-up test case
constructed with the query “A new era with technology NOT A new era with
science” to return items matching “A new era with technology” but excludes those
with keyword “A new era with science” should have no items in common.

2.4.5.

Complete

This pattern includes those relations where the source output and the follow-up
outputs should contain the same items. This pattern sounds quite similar to the
Equality and Equivalence pattern but the only thing different in this pattern is that
unlike other patterns, this one requires that all of the follow-up outputs’ union
should include the same items as the source output. For example, a search
query restricting to three different published date parameters on Google’s
Blogger, “now”, “before 2010” and “before now till 2010”. Intuitively, the union of
these queries should contain the same blogs as the source output with no filter.
10

2.4.6.

Difference

This pattern represents those metamorphic relations where the source output
and the follow-up outputs should differ in a specific set of items I, i.e, F1 / S = D.
For example, a source test case is constructed by creating a new public blog with
tag “Science” and title “Science and technology” and a follow-up test case is
created with tag “Technology” and title “Science and technology”. Intuitively, the
output of both tests should differ in the tag and other predefined properties like
author, url and so on but should match with other properties like location, posts
and so on.

2.5.

Related Works

Security testing validates the confidentiality, integrity, availability, authenticity of a
system. Felderer et al. have categorized security testing in two parts, functional
testing, which checks whether the security properties are implemented correctly
or not and vulnerability testing simulates attacks which target specific parts of the
system [1]. There are limited tools available for security testing of REST APIs.
SMRL presented by Mai et al. covers the security testing of web systems using
metamorphic security testing approach [22]. The problem with this approach is
that it uses web crawlers to go through the interface of the service and collect
data for security testing. The tool itself is not useful for REST APIs but the
implementation has a general definition of metamorphic testing. Similarly, another
paper by Segura et al. presented MROPs to test the RESTful Web APIs, which
lacks in the security aspects of the system under test [21]. So, this thesis
implemented security aspects from SMRL using MROPs to test the REST APIs.
In the sections below, a few research papers covering the aspects of
metamorphic testing, RESTler and some of its extended versions are discussed.

2.5.1.

RESTler: Stateful REST API Fuzzing

11

Atlidakis et al. introduced RESTler in this paper, the first stateful REST API
fuzzing tool [9] The simplicity and dynamic features of REST APIs makes it the
most used service to programmatically access the cloud services. As previously
discussed, it uses HTTP/S protocol and offers CRUD methods for the resources
on the cloud. The benefit of using REST APIs is that it can be documented using
interface-description language like OpenApi [23] It documents all the endpoints of
the resource that are accessible by which methods and the responses on
success and failure as well the response format.
The question arises, how secure the APIs are? Although there are many tools
available for automatic testing of the cloud services, the reliability of them are still
in their infancy. At Microsoft’s research center, the first stateful fuzzing tool called
RESTler was developed to automatically test the REST APIs endpoints. The tool
generates a sequence of requests to test deeply lined services behind REST
APIs.
The experimental results show that this type of fuzzing is required to prune large
search spaces of possible requests. It found 28 bugs in GitLab and several bugs
in each of the Azure and Office365 cloud services tested.

2.5.2.

Checking Security Properties of Cloud Service REST
APIs

The rise of cloud computing and cloud services over the last decade have been
enormous. Some of the major providers like Microsoft Azure [24], Google Cloud
Platform [25] are shaping the future digitally by providing huge infrastructures
and resources over the cloud.
Atlidakis et al. presented four novel security rules which extend RESTler and
their aim is to capture some of the desirable properties of REST APIs and
resources. The rules are as follows [8]:

12

a. Use-after-free rule: A deleted resource must not be accessible.
b. Resource-leak rule: A resource with unsuccessful creation must not be
accessible and stop any side-effects to the backend service.
c. Resource-hierarchy rule: A child resource of a parent resource must not
be accessible from another parent resource.
d. User-namespace rule: A resource created in a user namespace must be
assigned to the same user and must not be accessible by another user
namespace.
The above mentioned rules are the blueprint for the design and implementation
of active checkers. The paper covers the detailed design as well as experimental
results to evaluate its performance and effectiveness. The researchers were able
to find new bugs in several deployed production Azure and Office265 cloud
services.

2.5.3.

Metamorphic Security Testing for Web Systems

Metamorphic testing is a property based testing technique which is generally
applicable to test oracle problems and test case generation problems. The paper
by Mai et al. specifically covers metamorphic testing approaches to alleviate
oracle problems in security testing by specifying metamorphic relations (MRs)
which captures security properties of the system. The approach targets 39
percent of the Open Web Application Security Project (OWASP) security testing
tasks which are not automated by state-of-the-art techniques [22].
The approach provides an editor which is implemented as a plug-in for Eclipse
IDE[26]. It is built on top of a Domain-Specific Language (DSL), a catalog of MRs
targeting security vulnerabilities [27], a framework to automate the collection of
data and a testing framework to automate the security testing based on the MRs.
The approach was applied in a commercial Web system and in Jenkins [28].The
13

approach detected 100 percent and 75 percent vulnerabilities affecting those
systems respectively. The first step is to select MR based on the problem in the
hand from a catalog of predefined MRs followed by the toolset automatically
transforming them into executable Java code. In the second step, an in-built web
crawler is used to collect information about the system under test like URLs
which can be visited by an authenticated user. In the final step, the tool
automatically loads the inputs required by MRs and generates follow-up inputs as
per the relation. The result from the source and follow-up inputs are checked
according to the MRs.

3. RESTler
RESTler is the first automatic stateful REST API fuzzing tool [29]. Fuzzing means to
provide massive random data, called fuzz in an attempt to make the system crash and
find the loophole.

3.1.

Introduction

RESTler analyzes the entire specification based on OpenAPI specification, and
generates and executes tests through its REST APIs [29]. It infers producer-consumer
dependencies among request types from the swagger specification and dynamically
learns how the service responds to prior service responses as seen in the Fig. 2.2.

Fig. 2.2 : RESTler Architecture [1]

14

RESTler runs in four main modes as below in the same order:
● COMPILE : Generates a RESTler grammar from OpenAPI specification in JSON
or YAML format. For example, “restler.exe compile --api_spec <full path to API
specification>”, this code will generate grammar (grammar.py, grammar.json,
dict.json) and templates for fuzzing.
● TEST : Quick execution of all API endpoints from the compiled RESTler
grammar. For example, “C:\RESTler\restler\Restler.exe test --grammar_file
<RESTLer grammar.py file> --dictionary_file <RESTler fuzzing-dictionary.json
file>”, the code takes previously generated files from COMPILE mode and
produce logs file with the results of the experiment.
● FUZZ-LEAN : Executes once every API endpoints from the compiled RESTler
grammar with the default set of checkers. For example,
“C:\RESTler\restler\Restler.exe fuzz-lean --grammar_file <RESTLer grammar.py
file> --dictionary_file <RESTler fuzzing-dictionary.json file>”, similar to the TEST
mode, it takes compiled grammar files and outputs the results in the result folder.
● FUZZ : An extensive and aggressive aka Bug Hunting (deeper search mode),
typically takes a longer time than other modes and might create a break or
leakage on poorly implemented resources. For example,
“C:\RESTler\restler\Restler.exe fuzz --grammar_file <RESTLer grammar.py file>
--dictionary_file <RESTler fuzzing-dictionary.json file> --time_budget <max
number of hours (default 1)>”, similar to the FUZZ-LEAN mode, it takes compiled
grammar files, optionally time budget to let the program know how long it should
run and outputs the results in the result folder.
RESTler currently has two categories for bugs found:

15

● Error Code : A bug is reported if the response status code is “500” (Internal
Server Error)
● Checkers : Each checker tries to find additional bugs by targeting more
resources or request sequences while fuzzing. While some checkers try to find
additional “500” errors, others try to find logical bugs such as resource leak or
other violations.

3.2.

Methodology

The proposed methodology is to implement MROPs to extend the testing ability
of the tool. RESTler uses checkers to perform the testing, but the approach
defined here uses MROPs which uses a metamorphic approach to test the
system. As mentioned in the chapter 3.1, the tool consumes OpenApi
specifications, compiles it to produce a grammar file which identifies all request
types, producer/consumer dependencies, and generates code to parse service
responses. The generated grammar file is used to execute and analyze tests.
Each test in RESTler is defined as a sequence of requests and responses. The
tests are generated by [9]:
1. Inferring dependencies among request types from specification file e.g., if
a response of a request A is needed as input argument for another
request B, i.e A should be executed before B.
2. Analyzing dynamic feedback from older responses during test e.g, a
request C after a request A; B is rejected by the service i.e avoiding such
order in the future executions.
The working of the tool is described thoroughly in the following sections.

3.2.1.

Processing OpenAPI Specifications

The OpenAPI Specification, originally known as the Swagger Specification, is a
specification file for describing, consuming, and visualizing RESTful web
services. The complete working of a REST API resource is described in a well
16

documented OpenApi specification file. A client program sends requests to a
service and receives responses. The specification file consists of documentation
of methods, parameters, and models. The OpenApi tool on top automatically
generates a web UI that allows users to view the documentation and interact with
the API. This in general helps keep the documentation, source code and client
libraries in sync[29]. The OpenAPI specification for the case study in the thesis,
in web-UI form is shown in Fig. 4.1.1(1) .

Fig. 4.1.1 (1) : OpenAPI web-UI form
The image above shows that the case study consists of five endpoints. The
OpenAPI specification file consists of detailed information of above endpoints.
Sample description of POST /api/add endpoint is shown in Fig. 4.1.1 (2) .

17

Fig. 4.1.1 (2) : OpenAPI specification
The text above is in JSON format and describes the syntax expected for the
given request and its response. In this case, the second line after paths i.e,
“/add/” is the path or the address of the endpoint. The line followed by that “post”
is the request type i.e, POST request. Moving on, the request type consists of
different parameters like operationId, gives an id for the given request,
description, provides a short description on what the request does to give a
general idea to new users, parameters, includes the body of the request to post,
responses, gives status codes and data depending on the request, tags, to
organize the order of the tags that can be used by the parsing tools, and the last
parameters, is to provide id or other details to attach to the url of the endpoint.

18

The above specification file is converted into a grammar file which is encoded in
executable python code by RESTler (Fig. 4.1.1 (3)) .

Fig. 4.1.1 (3) : Grammar.py file
The above image shows that the code consists of HTTP requests and code to
process the request. Each restler_static function adds the mentioned string with
some parameters in some cases. The function restler_fuzzable_string or
restler_fuzzable_int takes a value from the dictionary of values for the given type,

19

which is discussed in the next section. The function parse_blogposts is
generated by RESTler automatically which stores the necessary information like
id and body of the request to use it in other resources where a dynamic object is
needed. For example, from Fig. 4.1.1 (1), some addresses require id to perform
the request, in such cases RESTler will use ids stored with the help of parser i.e,
parse_blogposts in this case. This helps to sync other requests as when a new
blog is created, all other actions like edit, delete, get depends on the id of the
newly created blog. This producer-consumer dependencies automates the
RESTler which is necessary for test generation in later stages.

3.2.2.

Main Algorithm

RESTler is implemented in 3,151 lines of modular python codes splitted into:
parser and compiler module, fuzzing module, and garbage collector module [9].
The main algorithm for test generation is shown below.

20

Fig. 3.1.2 (1) : RESTler Main Algorithm[9]
The algorithm computes request sequences as denoted by seqSet which is
empty at the beginning. A valid sequence is a response with status code in range
200. The algorithm computes valid request sequences upto user-specified
maxLength. The valid sequences are extended as per the line 9 to create a new
set of sequences by appending each request with satisfied dependencies as
described in the EXTEND (line 14) function. The DEPENDENCIES (line 39)
function verifies that all of the references of the specified request are satisfied,
21

which is helped by CONSUMES (line 45) and PRODUCES (line 48) helper
functions. The DEPENDENCIES function is true if every dynamic object required
by the CONSUMES function is produced by response to the preceding request in
the PRODUCES function. Once it passes the loop, each newly-extended request
sequence is rendered (line 10) one by one as shown in the RENDER function
(line 23). In this function, it concretizes all newly appended requests using valid
dictionary values and in every iteration, executes new requests and keeps only
the valid ones. The in-depth architecture and algorithm of the tool is described in
the paper RESTler: Stateful REST API Fuzzing by V Atlidakis et al. [9].

3.2.3.

Authentication

RESTler supports only token-based authentication at the moment. A separate
script file which implements the API’s authentication method is passed through
the command line. The file is invoked in a separate process by RESTler to obtain
and refresh the tokens regularly. The authentication method is optional and
depends on the resource. RESTler supports a maximum of two tokens, which is
only used by namespace checker. The checker is turned on manually by
specifying the command line enable_checkers and the name of the checker.
The token refresh parameter is --token_refresh_cmd “python3 get_tokens.py”
and --token_refresh_interval provides frequency to obtain new tokens. The
get_tokens.py file consists of metadata which is to be printed in the format below:
{u'app1': {<any additional metadata you'd like to print. currently only
used for troubleshooting. >}, u'app2':{}}
ApiTokenTag: 9A
ApiTokenTag: ZQ

The tool has logic implemented which prevents token values being printed to the
network logs.

3.2.4.

Extending RESTler

22

RESTler is implemented in the object oriented paradigm which eases the
process of extending the tool and implementing new features. The tool
implements checkers for additional bug hunting which is not carried out in normal
fuzzing. The easiest way to extend the tool is by creating a new checker and
enabling it during the fuzzing i.e fuzz-lean or fuzz mode. The command to enable
a checker is --enable_chechers NewChecker and to disable a checker
--disable_checkers NewChecker.
The checkers are created as a subclass to the CheckerBase abstract class. It
consists of functions and data members responsible for synchronizing across the
checkers. It also declares functions that are required for a newly implemented
checker subclass. It consists of following data members and functions.
Data Members:
● _checker_log: Log file for the checker.
● _req_collection: RequestCollection object which is shared throughout the
restler.
● _fuzzing_requests: FuzzingRequestCollection object which consists of all
requests being fuzzed.
● _enabled: If the checker is enabled or disabled during this run.
● _friendly_name: The name used to enable/disable checkers from the
command-line with parameters --enable_checkers {_friendly_name}
● _connection_settings: IP address, Port and other socket connection
settings.
● _mode: The checker’s mode ( normal, exhaustive, or other, optionally
used by checkers)
Functions:
● apply: It is the checker’s entry point. It is an abstract function which is
compulsory for a new checker and is called after sequences are rendered.
● _send_request: It sends a request to the resource and returns the
response. The function request_utilities.call_response_parser() should be

23

called to update resource dependencies and make data visible to the
garbage collector.
● _render_and_send_data: It renders data for a request, sends the request,
and then adds the rendered data and the response to sequence’s
sent-request list.
● _rule_violation: A helper function to check whether a rule is violated or not.
It checks a response’s status code for “500” or “2xx” and optionally calls
_false_alarm.
● _false_alarm: It is defined as False by default as is called by
_rule_violation. The purpose of this function is to catch scenarios that fail
the rule violation check, but are not actually a rule violation.
● _print_suspect_sequence: A helper function that prints the sequence’s
definition. It should be called if a rule violation is detected.

3.2.5.

Current Limitations

The tool has a stable version released in github. But the tool itself has certain
limitations and bugs at the moment. Some that were found during the
implementation of this thesis is mentioned below:
● RESTler doesn’t support requests for API endpoints with server-side
redirects i.e 3xx status codes.
● It can only find bugs defined as unexpected HTTP status codes, for
example it cannot detect vulnerabilities which are not visible through
HTTP status codes like, information exposure and others.
● It only supports token-based authentication.

24

4. Design and Implementation
This section discusses the methods used to implement the metamorphic testing
approach in the RESTler tool. It also covers how to set up the tool and get
started with it.

4.1.

Implementation

The chapters above show the basic structure of RESTler and how it can be
extended to implement new features. The aim of this thesis is also to extend the
tool to implement a Metamorphic approach for the fuzzing purpose. The detailed
implementation of each pattern is discussed in section 4.3 and its sub sections.
The main point of this approach is to improve the security aspect of RESTler. So,
each MROPs focus on the security aspect of the system under test. The quick
overview of the implementation is such that status codes from source output and
follow output are collected and then compared to satisfy certain relation patterns.
Most of the tests will consist of two users i.e,authenticated via tokens and will be
tested against the users which verifies the security aspect of the system. The
following chapters demonstrate the case studies and complete implementation of
each relation pattern.

4.2.

Current Case Study

The case study in this thesis is a Blog application which uses REST architecture.
The output is in Javascript Object Notation (JSON) format . The architecture is
shown below:

25

Fig. 4.2 (1) : RESTful Architecture
The architecture sits on top of the stateless nature of REST API . As from the
diagram above, the client sends a request type with queries and receives data
from the database in JSON format. REST architecture is stateless which means
that the client’s state is not stored on the server-side. Each request to the server
must contain all of the information necessary to execute the request like
authorization tokens, contents and other details. In other words, it means that the
request happens in complete isolation. The client is responsible for storing the
necessary information to fulfill the request and the server never relies on
information from last requests. This attribute of REST APIs provides many
benefits to the system, some of them are as follows:
● Statelessness helps to scale APIs to concurrent users by deploying it to
multiple servers because any server can handle any request as there is no
session related dependency.
● With no server-side state synchronization logic, the use of this architecture
is less complex.
● The client sends all necessary information with every request which
makes the server never have to store any information.
The web service is developed using Django REST framework (Christie ) and
simple token based authentication from the framework itself. The blog user and

26

respective token is created using Django’s admin panel and is not included in the
endpoints to reduce the complexity. The endpoints are as follows[30]:
1. GET /api/blog : This endpoint supports only GET requests and returns all
blogs as response. It takes no parameters and only has a response code
of 200 unless there is server error. The informations required to perform
the request is as follow:
Authorization: Not required
Body: None
Parameters: None
Responses:
{
Data:{ Items },
status: 200
}

2. POST /api/add : This endpoint addresses POST requests which adds a
new blogpost to the database. The informations required to perform the
request is as follow:
Authorization: Token
Body:
{
title*

string
title: Title
maxLength: 40
minLength: 1

description*

string
title: Description
maxLength: 45
minLength: 1

27

posted_by*

string
title: Posted by
maxLength: 45
minLength: 1

}

Parameters: None
Responses:
{
data:{ Added Item },
status: 201
}
{
message: “Bad request”
status: 400
}
Upon successful response with status code 201, serialized data is as
follow:
{
"id": "id",
"title": "title",
"description": "description",
"created_date": "created_date",
"posted_by": "posted_by"
}

3. GET /api/blog/{id}: This endpoint addresses a GET request which
returns the blog with a given blog id. The informations required to perform
the request is as follow:
Authorization: Token
Body: None
28

Parameters: id (Blog Id)
Responses:
{
data:{ Single Item },
status: 200
}
{
message: “Couldn’t find item with such Id”
status: 404
}
Upon successful response with status code 200, serialized data is as
follow:
{
"id": "id",
"title": "title",
"description": "description",
"created_date": "created_date",
"posted_by": "posted_by"
}

4. DELETE /api/delete/{id}: This endpoint addresses a DELETE request
which deletes the blog with a given blog id. It also matches that the
requested id of the blog belongs to the current user. The informations
required to perform the request is as follow:
Authorization: Token
Body: None
Parameters: id (Blog Id)
Responses:
{
message:“Deleted Successfully”,
status: 200
}

29

{
message:“Couldn’t find item with such ID”,
status: 404
}
{
message:“Not authorized to delete this data.”,
status: 401
}

5. PATCH /api/edit/{id}: This endpoint addresses a PATCH request which
updates the partial or complete details of the blog with given blog id. It
also verifies that the requested id of the blog belongs to the current user.
The informations required to perform the request is as follow:
Authorization: Token
Body:
{
Title: string
description: string
}
Parameters: id (Blog Id)
Responses:
{
data: { Edited blog}
status: 200
}
{
message:“Bad Request,
status: 400
}

30

{
message:“Couldn’t find item with such Id”,
status: 404
}
Upon successful response with status code 200, serialized data is as
follow:
{
"id": "id",
"title": "title",
"description": "description",
"created_date": "created_date",
"posted_by": "posted_by"
}

4.3.

Implementation of Metamorphic Relation Output
Patterns

This thesis implements six different MROPs which capture different metamorphic
relations found in RESTful Web APIs[21]. The implemented patterns are dynamic
and work with any web services that follow the REST architectural style. Chapter
2.4 consists of detailed information on these six different MROPs. The following
subsections describe how those patterns are implemented in this thesis’s case
study. The patterns are as follow:

4.3.1.

Equivalence

This pattern represents the relations having the same source and follow-up
outputs, although not necessarily in the same order. The type of requests that
this relation satisfies are as follows:

31

● POST-DELETE-same resource : The POST request’s status codes with
valid token1 should have equivalence relation from the DELETE request’s
status codes with the same token1. This verifies that the user can post
and delete their own resources.
● POST-PATCH-same resource : The POST request’s status codes with
valid token1 have equivalence relation from the PATCH request’s status
codes with the same token1. This verifies that the user can post and edit
their own resources.
To prove the Equivalence MROP, POST-DELETE-same resource method is
implemented. The relation to satisfy this pattern is such that POST and DELETE
requests with the same authorization token on any endpoints of the API should
return the same status codes. The code snippet of the pattern is as below:

Fig. 4.3.1 (1) : Equivalence MROP
The function above is pretty simple as it first takes the latest request/path sent by
RESTler and splits the first part to find the request type. As our request already
consists of one token, so the authorization part is already taken care of. The
second step is to check the request type and return status codes depending on
the request type. To return the status codes, a helper function called
_render_original_sequence_start() which will also be used in other patterns and
will be referred by the name is called which looks like below:

32

Fig. 4.3.1 (2) : Helper function to render original sequence
The above function helps to render the original sequence of the requests. The
function goes through the requests and gets the rendered data and parser. In the
later stage, it sends requests using the parser and rendered data and calls the
response parser from request_utilities which returns the status code in order of
POST and DELETE respectively.

Fig. 4.3.1 (3) : Main function to call the MROP

33

The main function begins by checking whether the rendered sequence is valid or
not and locking the thread if it is not locked. In the second step, it calls
_get_authentication_method which does a simple check if there is a token
attached to the call or not and if there is more than one token in the script. The
final call to the Equivalence function is made after everything is in order and the
status codes are stored in the dependencies as the checker runs for every
request, it is wise to store the status codes somewhere else to verify the relations
of the status codes. The status codes are stored with a simple one line function
which looks like below:

Fig. 4.3.1 (4) : Storing status codes in dependencies
The verification of the status codes is done at the main file which is called
restler.py. The code to check whether the stored status codes satisfies the
relationship or not is as below:

Fig. 4.3.1 (5) : Verification of the Equivalence MR

34

The code above starts first by collecting the status codes from the dependencies
and then it loops through the status codes which are in orders of POST and
DELETE requests respectively and returns a boolean value. The test is passed if
all of the status codes start with the same status code type. For example either
with 2xx, 4xx, 5xx depending on the input. If it passes the test, a successful log
message is sent. The outcome of the test looks like below:

Fig. 4.3.1 (6) : Equivalence MR Output

4.3.2.

Equality

This pattern represents the relations having the same source and follow-up
outputs in the same order. Based on the current case study, all POST requests
with two valid tokens should contain the same status codes in the same order.
The fact that all resources are available for both of the tokens is taken into
consideration. The code snippet of the main function to execute the relation is as
below:

35

Fig. 4.3.2 (1) : Equality MR with multiple tokens
The code block above also starts with identifying the latest request and its type. If
the request type is POST, it renders the original sequence with the first token and
with the help of _change_user_identity function, it uses the second token to send
the request. If everything goes well, the response status code with both tokens
are collected as a dictionary object. The _change_user_identity function looks
like below:

36

Fig. 4.3.2 (2) : Change user identity function
The helper function above imports two tokens from the payload. If the
authentication method doesn’t have the refreshable authentication token, it
automatically breaks the function. If both tokens are present in the script, it
swaps the token1 with token2 and sends new request data. The function is called
in the main apply function and status codes are set to the dependencies as
below:

Fig. 4.3.2 (3) : Code to call the equality MR and set dependencies

37

The first line calls the Equality MR and upon receiving the status codes, the
second line sets the status codes to the dependencies which will be retrieved
later in the restler.py to check the relation between the status codes. The function
to set the status codes looks like below:

Fig. 4.3.2 (4) : Function to set the status codes
The first line calls the Equality MR and upon receiving the status codes, the
second line sets the status codes to the dependencies which will be retrieved
later in the restler.py to check the relation of the requests. The code snippet to
check the relation looks like below:

Fig. 4.3.2 (5) : Code to test the Equality MR
The above code gets the status codes in the first line and sets equality_test_pass
to false. The other lines print metadata which is useful for viewing purposes and
loops through all the status codes which are paired in request with token1 and
token2 together. The seventh line checks if the first status code and second code
match exactly, which reflects that the status code matches and is in the same

38

order as well. If true, it sets equality_test_pass to true otherwise false. Upon
successful iteration and with true euality_test_pass, final metadata of successful
execution is printed. The output of the final test looks like below:

Fig. 4.3.2 (6) : Result of the execution
The result above shows that all of the status codes in pairs match exactly which
justifies the Equality MR.

4.3.3.

Subset

This pattern represents those, where the follow-up outputs should be the subsets
of the source output. Based on the current case study, all requests with a valid
token should always have more status codes with 2xx response. The type of
request this relation satisfies is COUNT-All-Requests-Valid-Invalid-Tokens. In
brief, the total requests count with valid tokens should always be greater or equal
but not less than that with invalid tokens. Two separate functions are
implemented to collect status codes with valid and invalid token respectively and
later on compared to prove the relation pattern. The code snippet of the main
function is as below:

39

Fig. 4.3.3 (1) : Simple request to collect all status codes
The function above is pretty simple as it renders all sequences and returns the
status codes from the response. In Fig. 4.3.1 (2), the detailed working of function
_render_original_sequence_start can be seen. Following to this function, another
function which collects all status codes from invalid token is as below:

Fig. 4.3.3 (2) : Subset function to collect status codes from invalid token
The function above separates the rendered data and parser from the request
collection. And upon resolving the dependencies, it changes the identity to invalid
token with the help of helper function _change_user_indentity as seen in the Fig.
4.3.2 (2). When the identity is changed, it sends the request and calls a response
parser which returns the status codes. The status codes are stored in

40

dependencies as shown in other examples also. The following code stores the
status codes in the dependencies:

Fig. 4.3.3 (3) : Code to call the subset MR and set dependencies
The code above calls both function with valid and invalid token and sets the
returned status codes in the dependencies with the help of
set_subset_status_codes function which looks like below:

Fig. 4.3.3 (4) : Function to set the subset status codes
The above function checks if both values received is not None and then sets the
status codes accordingly which later in the restler.py will be received to check the
relations. The final lines of code to check the relation is as below:

41

Fig. 4.3.3 (5) : Code to test Subset MR
The above lines of codes checks whether the service passes the subset MR
check. The first two lines collect status codes for valid and invalid token
respectively from the dependencies. The two for loops collects the count of
status codes with valid token and invalid token to two separate variables
subset_good_token_status_codes and subset_bad_token_status_codes
respectively. The next four print statements print the metadata of both status
codes which visualizes all of the status codes. The last if statement checks if the
total count of status codes with bad token is less than the total count of status
codes with good token and if it is true, it passes the subset MR. The output of
test looks like below:

42

Fig. 4.3.3 (6) : Result of Subset MR
The result above shows that the total count of 2xx status codes with invalid token
is less than the total count of 2xx status codes with valid code, which pasess the
Subset MR.

4.3.4.

Disjoint

This pattern represents those, where the intersections between follow-up outputs
and the source output should be empty. Based on the current study, all POST
requests with a valid token and an invalid token shouldn’t have the same status
codes at all. Since, a POST request always requires a valid token, only POST
request is checked which also provides clarity to the relation. The type of
requests that this relation satisfies are as follows:
● POST-PATCH-Cross-Resources: The POST request’s status codes with
valid token1 should be disjoint from the PATCH request’s status codes
with valid token2. This verifies that the user1 cannot access the resource
of user2 and vice versa.
● POST-DELETE-Cross-Resources: The POST request’s status codes with
valid token1 should be disjoint from the DELETE request’s status codes
with valid token2. This verifies that the user1 cannot access the resource
of user2 and vice versa.

43

● POST-POST-Valid-Invalid-Token: The POST request’s status codes with
token1 should be disjoint from the POST request’s status codes with
invalid token2. This verifies that the authentication method in the POST
endpoint is working properly.
To prove the Disjoint MROP, POST-POST-Valid-Invalid-Token method is
implemented. The main function is divided into two functions i.e one with valid
token and other without token. As RESTler only accepts a token via script, it was
impossible to tweak the token to an invalid one. The only possible way to
implement invalid token was by providing an invalid token to get_tokens.py itself
which RESTler executes during the processing.

Fig. 4.3.4 (1) : Script to generate token
The code above prints authorization tokens in the format RESTler supports. The
code snippet of the main function to execute the relation is as below:

Fig. 4.3.4 (2) : POST request with valid token

44

The code above collects status codes for the POST request with a valid token.
The first two lines print the request type and third line checks if the request type
is POST, the return statement returns the status codes which later on will be
stored in the dependencies to prove the relation.

Fig. 4.3.4 (3) : POST request with invalid token
The code snippet above collects rendered_data and parser from the
_req_collection and splits the first request to check the request type. The later
part of the code resolves the dependencies with the help of
resolve_dependencies helper function and if the request type is POST and
changes the user identity with invalid token by calling _change_user_identity i.e
helper function. The detailed working of the helper functions are mentioned in the
Equivalence MR part i.e chapter 4.3.2(2) and 4.2.1(2).

Fig. 4.3.4 (4) : Code to call the equality MR and set dependencies

45

The code above calls both function with valid and invalid token and sets the
returned status codes in the dependencies with the help of
set_disjoint_post_codes function which looks like below:

Fig. 4.3.4 (5) : Function to set the disjoint status codes
The above function checks if both values received is not None and then sets the
status codes accordingly which later in the restler.py will be received to check the
relations. The final lines of code to check the relation is as below:

Fig. 4.3.4 (6) : Code to test Disjoint MR
The picture above shows the code which tests the relation by comparing the
status codes. The first two lines of code get the status codes and set
disjoint_test_all_code_no_match to false. After that, two nested loops are used to
iterate over status codes with valid and invalid tokens and upon each disjoint with
another, the disjoint_test_all_code_no_match is set to true. The remaining lines

46

print metadata which is useful for viewing purposes and a successful message is
displayed if the disjoint_test_all_code_no_match is true. The output of the test
looks like below:

Fig. 4.3.4 (7) : Result of Disjoint MR
The result above shows that all of the status codes in both lists are distinct which
justifies the Disjoint MR.

5. Evaluation and Discussion
This chapter covers the testing, results and findings from the implemented
approach. Besides this, it also discusses all experiments done to achieve these
results.

5.1.

Testing

Testing is an integral part of the software development process and enhances the
quality of the products[31]. In simplest terms, testing validates whether the
developed method or tool behaves as intended and identifies potential
malfunctions. There are different methods of testing which can be applied
depending on the system under test. To validate the tool developed in this thesis,
a software bug seeding is done. The previous chapter showed the results of the
individual patterns which showed the tool behaves correctly with a functioning

47

resource. In the following chapters, bugs with different threats to the system will
be implemented and the results from them will be discussed.

5.1.1.

Bug Seeding

It is a technique to evaluate software issues residing in the system by
contaminatinating the system with artificial errors. The bugs to exploit different
parts of the system and the tools are mentioned below. These bugs verify that
the tool as a whole covers all the edge cases of resource leak.
1. No User Match-Making on Edit Endpoint:
This bug removes the user verification check while editing the blog i.e the
endpoint requires the user to be logged in but does not check whether the user
from the current token and the owner of the blog post matches. This bug gives
unauthorized access to any user to access and edit any resources.

Pattern

Expected Result

Result with
checker

POST-EDIT-Cross-Resources

Pass

Fail

POST-DELETE-Cross-Resources

Fail

Fail

POST-DELETE-Same-Resource

Pass

Pass

POST-DELETE-Valid-Invalid-Tokens

Fail

Fail

POST-POST-Valid1-Valid2-Tokens

Pass

Pass

COUNT-All-Requests-Valid-Invalid-Toke
ns

Count(Invalid<=Vali Count(Invalid<=V
d)
alid)

Table 1.1: No User Verification on Edit endpoint

48

2. No User Match-Making on Delete Endpoint:
This bug removes the user verification check while deleting the blog i.e the
endpoint requires the user to be logged in but does not check whether the user
from the current token and the owner of the blog post matches. This bug gives
unauthorized access to any user to access and delete any resources.

Pattern

Expected
Result

Result with
checker

POST-EDIT-Cross-Resources

Fail

Fail

POST-DELETE-Cross-Resources

Pass

Fail

POST-DELETE-Same-Resource

Pass

Fail

POST-DELETE-Valid-Invalid-Tokens

Fail

Fail

POST-POST-Valid1-Valid2-Tokens

Pass

Pass

COUNT-All-Requests-Valid-Invalid-Tokens

Count(Invalid Count(Invalid<=
<=Valid)
Valid)

Table 1.2: No User Verification on Delete endpoint

3. Preventing delete endpoint for the resource owner :
This bug prevents the authenticated owner of the blog post from deleting own
blog. The intention of this bug is to trigger if an authenticated user is able to
create and delete a blog. The token validation is done, so it still prevents
unauthorized access to the endpoint.

Pattern

Expected
Result

Result with
checker

POST-EDIT-Cross-Resources

Fail

Fail

49

POST-DELETE-Cross-Resources

Fail

Pass

POST-DELETE-Same-Resource

Pass

Fail

POST-DELETE-Valid-Invalid-Tokens

Fail

Fail

POST-POST-Valid1-Valid2-Tokens

Pass

Pass

COUNT-All-Requests-Valid-Invalid-Tokens

Count(Invalid Count(Invalid<=
<=Valid)
Valid)

Table 1.3: Preventing delete endpoint for the resource owner
4. No User Match-Making on Delete Endpoint:
This bug removes the user verification check while deleting the blog i.e the
endpoint requires the user to be logged in but does not check whether the user
from the current token and the owner of the blog post matches. This bug gives
unauthorized access to any user to access and delete any resources.

Pattern

Expected
Result

Result with
checker

POST-EDIT-Cross-Resources

Fail

Fail

POST-DELETE-Cross-Resources

Fail

Pass

POST-DELETE-Same-Resource

Pass

Pass

POST-DELETE-Valid-Invalid-Tokens

Fail

Fail

POST-POST-Valid1-Valid2-Tokens

Pass

Pass

COUNT-All-Requests-Valid-Invalid-Tokens

Count(Invalid Count(Invalid<=
<=Valid)
Valid)

Table 1.2: No User Verification on Delete endpoint
5. No authentication check on every endpoints:

50

This bug removes the authentication check from all endpoints which ignores the
valid or invalid token while accessing the resource. The intention of this bug is to
trigger as many patterns as possible and especially count all requests with valid
tokens which should always be greater or equal to the invalid token. If the
request count is equal, it suggests either there is a wrong implementation of the
authentication or all of the resources do not require authentication tokens.

Pattern

Expected
Result

Result with
checker

POST-EDIT-Cross-Resources

Fail

Pass

POST-DELETE-Cross-Resources

Fail

Pass

POST-DELETE-Same-Resource

Pass

Pass

POST-DELETE-Valid-Invalid-Tokens

Fail

Pass

POST-POST-Valid1-Valid2-Tokens

Pass

Pass

COUNT-All-Requests-Valid-Invalid-Tokens

Count(Invalid<
=Valid)

Count(Invali
d==Valid)

Table 1.2: No authentication check on every endpoints

5.2.

Discussion

The introduced method presents a new way of finding the reachability and
readability of the request error in the endpoints. The introduced method
increases the chance of finding out exactly what is the faulty request endpoint.
As mentioned in the introduction and limitation of RESTler, it only provides the
error code if the request is not successful, so it is impossible to track what might
be the reason for this failed request.
The method proposed in the thesis is an improvement to the method used by
RESTler, which is why there are no concrete results in numbers to figure out the
51

comparison between two methods. But, as discussed in previous chapters, the
relational output patterns quite drastically improves the tool and its use case for
the future.

6. Conclusions and Future Work
The final chapter summarizes the work done, recalls the research questions and
few things which can be implemented in the future.

6.1.

Conclusions

This thesis presented a metamorphic approach to extend the RESTler tool. The
approach considered the system under test as a web service which is built on
REST architecture and satisfies the requirements of RESTler. RESTler has
built-in checkers to check different logical bugs in the system, apart from that it
only treats the error code 5xx as a bug. The purpose of this thesis was to present
a new method which could improve the testing and security of the system.
The result and evaluation from the previous chapter shows that the implemented
method increases the effectiveness of the tool. The main task in this thesis was
to implement the metamorphic relation in the tool and it was one of the research
questions mentioned. The MROP approach of metamorphic testing was used to
extend the tool. This method reduces the manual check of the expected output
and increases the efficiency of the tool in the base level.
This approach is suitable for industrial adoption with more test cases and
automation of the tests. As the tool, RESTler is open source and extendable, this
approach is just an example of what can be done with the tool.

52

6.2.

Future work

In this thesis, a new approach was presented to improve the testing strategy of
RESTler. The system under test was verified for its reachability, liveness and
security properties.
The implemented approach is using an automatic testing approach but it does
require manual intervention to some extent. It is also limited to the configuration
provided by RESTler. It also requires pre-defined metamorphic relationships
depending on the system under test. Currently, the method is tested in a small
system which limits the exploitation and verification of the developed tool. The
part of future work will be to cover more edge cases in the metamorphic relation
output patterns, generating MRs automatically and reduce the manual
intervention in testing completely.

7. References
[1] M. Felderer, M. Büchler, M. Johns, A. D. Brucker, R. Breu, and A. Pretschner, “Chapter One
- Security Testing: A Survey,” in Advances in Computers, vol. 101, A. Memon, Ed. Elsevier,
2016, pp. 1–51.
[2] “What is a REST API?” https://www.redhat.com/en/topics/api/what-is-a-rest-api (accessed
Aug. 10, 2021).
[3] “Web application security testing with AppSpider.”
https://www.rapid7.com/products/appspider (accessed Apr. 23, 2021).
[4] “Web Application Scanning.” https://www.qualys.com/apps/web-app-scanning/ (accessed
Apr. 23, 2021).
[5] J. Pereyda, boofuzz. Github. Accessed: Apr. 23, 2021. [Online]. Available:
https://github.com/jtpereyda/boofuzz
[6] TnT-Fuzzer. Github. Accessed: Apr. 23, 2021. [Online]. Available:
https://github.com/Teebytes/TnT-Fuzzer
53

[7] APIFuzzer. Github. Accessed: Apr. 23, 2021. [Online]. Available:
https://github.com/KissPeter/APIFuzzer
[8] V. Atlidakis, P. Godefroid, and M. Polishchuk, “Checking Security Properties of Cloud
Service REST APIs,” in 2020 IEEE 13th International Conference on Software Testing,
Validation and Verification (ICST), Oct. 2020, pp. 387–397.
[9] V. Atlidakis, P. Godefroid, and M. Polishchuk, “RESTler: Stateful REST API Fuzzing,” in
2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE), May 2019,
pp. 748–758.
[10] “Simple object access protocol (SOAP) 1.1.”
https://www.w3.org/TR/2000/NOTE-SOAP-20000508/ (accessed Apr. 27, 2021).
[11] S. Allamaraju, RESTful Web Services Cookbook: Solutions for Improving Scalability and
Simplicity. “O’Reilly Media, Inc.,” 2010.
[12] M. Masse, REST API Design Rulebook: Designing Consistent RESTful Web Service
Interfaces. “O’Reilly Media, Inc.,” 2011.
[13] J. Liang, M. Wang, Y. Chen, Y. Jiang, and R. Zhang, “Fuzz testing in practice: Obstacles
and solutions,” in 2018 IEEE 25th International Conference on Software Analysis, Evolution
and Reengineering (SANER), Mar. 2018, pp. 562–566.
[14] M. Boehme, C. Cadar, and A. Roychoudhury, “Fuzzing: Challenges and Reflections,” IEEE
Softw., vol. 38, no. 3, pp. 79–86, May 2021.
[15] peach: Peach is a fuzzing framework which uses a DSL for building fuzzers and an
observer based architecture to execute and monitor them. Github. Accessed: Aug. 18,
2021. [Online]. Available: https://github.com/MozillaSecurity/peach
[16] D. R. Apostolis, Ed., American fuzzy lop. DIC Press, 2012.
[17] “libFuzzer – a library for coverage-guided fuzz testing. — LLVM 13 documentation.”
https://llvm.org/docs/LibFuzzer.html (accessed Aug. 18, 2021).
[18] honggfuzz: Security oriented software fuzzer. Supports evolutionary, feedback-driven
fuzzing based on code coverage (SW and HW based). Github. Accessed: Aug. 18, 2021.
[Online]. Available: https://github.com/google/honggfuzz
[19] P. Godefroid, M. Y. Levin, and D. Molnar, “SAGE: Whitebox Fuzzing for Security Testing:
SAGE has had a remarkable impact at Microsoft,” Queueing Syst., vol. 10, no. 1, pp.
20–27, Jan. 2012.
[20] T. Y. Chen, S. C. Cheung, and S. M. Yiu, “Metamorphic Testing: A New Approach for
Generating Next Test Cases,” arXiv [cs.SE], Feb. 28, 2020. [Online]. Available:
http://arxiv.org/abs/2002.12543
[21] S. Segura, J. A. Parejo, J. Troya, and A. Ruiz-Cortés, “Metamorphic Testing of RESTful
Web APIs,” IEEE Trans. Software Eng., vol. 44, no. 11, pp. 1083–1099, Nov. 2018.
[22] P. X. Mai, F. Pastore, A. Goknil, and L. Briand, “Metamorphic Security Testing for Web
Systems,” in 2020 IEEE 13th International Conference on Software Testing, Validation and
Verification (ICST), Oct. 2020, pp. 186–197.
[23] “OpenAPI Specification.” https://swagger.io/specification/ (accessed Apr. 22, 2021).
[24] rolyon, “Azure documentation.” https://docs.microsoft.com/en-us/azure/?product=popular
(accessed Feb. 14, 2022).
[25] “Cloud Computing Services,” Google Cloud. https://cloud.google.com/ (accessed Feb. 14,
2022).
[26] Eclipse Foundation, Inc, “The Community for Open Innovation and Collaboration.”
https://www.eclipse.org/ (accessed May 04, 2021).
[27] “OWASP Foundation.” https://owasp.org/ (accessed May 04, 2021).
[28] “Jenkins.” https://www.jenkins.io/ (accessed May 04, 2021).
[29] “OpenAPI Specification.” https://swagger.io/specification/ (accessed May 03, 2021).
[30] T. Christie, “Home - Django REST framework.” https://www.django-rest-framework.org/
(accessed Jul. 07, 2021).
54

[31] A. Bertolino, “Software Testing Research: Achievements, Challenges, Dreams,” in Future of
Software Engineering (FOSE ’07), May 2007, pp. 85–103.

55

